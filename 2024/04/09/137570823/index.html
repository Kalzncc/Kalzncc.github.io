<!DOCTYPE html>

<html lang="zh-CN">

<head>
    
    <title>面试-数据库基础以及MySql、ClickHost、Redis简介 - Kalzn的个人博客</title>
    <meta charset="UTF-8">
    <meta name="keywords" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css"> <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
    <link rel="shortcut icon" href="/favicon.png" type="image/png" />
    <meta name="description" content="0.数据完整性 确保数据准确和一致，主要有以下四类约束： 实体完整性 主键完整 域完整性 键值数据类型 参照完整性 外键完整 用户定义的完整性 例如计数器必须大于0等用户自定义的完整性条件# 面试-数据库基础、MySql、ClickHost、Redis简介 1.数据库并发控制 1.1事物 事物是提交给DBMS执行的一系列操作。DBMS需要确保事物的操作序列被完整执行。即要么全部执行，要么回滚至事物">
<meta property="og:type" content="article">
<meta property="og:title" content="面试-数据库基础以及MySql、ClickHost、Redis简介">
<meta property="og:url" content="http://kalzncc.github.io/2024/04/09/137570823/index.html">
<meta property="og:site_name" content="Kalzn的个人博客">
<meta property="og:description" content="0.数据完整性 确保数据准确和一致，主要有以下四类约束： 实体完整性 主键完整 域完整性 键值数据类型 参照完整性 外键完整 用户定义的完整性 例如计数器必须大于0等用户自定义的完整性条件# 面试-数据库基础、MySql、ClickHost、Redis简介 1.数据库并发控制 1.1事物 事物是提交给DBMS执行的一系列操作。DBMS需要确保事物的操作序列被完整执行。即要么全部执行，要么回滚至事物">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/54698ada292a8595409ddb45fccf66df.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/104c6a52604180a5e89786a9c95b310a.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/5123418bc1f4f3ffad7940310477ea48.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/690f6ec72aa19755b847da70893f30bd.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/781a6f0e50f9584b4362c930bd445af1.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/c108db1eb3d0832963d01dabbf5c934f.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/470545716923b12e64ba9512c4379a22.png">
<meta property="og:image" content="file:///C:/Users/22612/AppData/Roaming/marktext/images/2024-04-08-17-20-34-image.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/571105f204584cef1c7d31be12a0b610.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/6ef53c54c17058df6007248615b8bb8c.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/7789bf7690ebdcb02e47ac896ed4f566.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/ce4cce91d190077c2a980174a08069eb.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/c1705452d563d02b70d92875793bc270.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/797f657dc266385296123fe4a9d81093.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/215cf87405f60dd8e3e911d8778b6361.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/0d44200ec02878be4935d11c983553f8.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/fc48b37fb567ad6db8a8d77d64585fa7.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/5bf2818bd4a206f20ff3fbcfc68c7f7c.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/2fa67201063e40be3f3ca311820e9a30.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/23e439acb14eca4d96618ebdcc244375.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/7eca656f8ad636697b9aaa0e829802ba.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/777e8ae6ffa39ddb578fcd5dd24a2c00.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/295d16a4babc713cd39ebaad25df6474.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/a41c32b2cb43da4bfda010d4cb1715e9.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/e8d626c7afb27c8f2d3bc5d097586050.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/2f7fa900d371692c0f5340992939b353.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/870748518224ec5e05be920bf0f93937.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/33d90d385e42686c4adbd99a0f2d38b3.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/6abc4b8a7d96f6312bb12383fdf19b9f.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/b108eec7e943a165af1580fb6d39ad08.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/4107bb0153180128da94d25f74b24a92.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/87b2fdb76a3afd96c013497abc23aa22.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/684aacc5b70e52d4b6327b9a0a8550e9.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/492d331da74d3ac366f4357205c1907f.png">
<meta property="og:image" content="http://kalzncc.github.io/2024/04/09/137570823/cd8fbe0103a6038be91ae140a4fb3250.png">
<meta property="article:published_time" content="2024-04-09T14:58:23.000Z">
<meta property="article:modified_time" content="2024-11-27T03:53:38.322Z">
<meta property="article:author" content="Kalzn">
<meta property="article:tag" content="八股">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://kalzncc.github.io/2024/04/09/137570823/54698ada292a8595409ddb45fccf66df.png">
    
<link rel="stylesheet" href="/lib/fancybox/fancybox.css">
<link rel="stylesheet" href="/lib/mdui_043tiny/mdui.css">


    <link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1732680051086">
    
    <link rel="stylesheet" href="/css/style.css?v=1732680051086">

    
        
            <link rel="stylesheet" href="/custom.css?v=1732680051086">
        
    



    <script src="js/echarts.js"></script>

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>

<body class="mdui-drawer-body-left">
    <div id="nexmoe-background">
        <div class="nexmoe-bg" style="background-image: url(/static/pic/back.jpg)"></div>
        <div class="mdui-appbar mdui-shadow-0">
            <div class="mdui-toolbar">
                <a mdui-drawer="{target: '#drawer', swipe: true}" title="menu" class="mdui-btn mdui-btn-icon mdui-ripple"><i class="mdui-icon nexmoefont icon-menu"></i></a>
                <div class="mdui-toolbar-spacer"></div>
                <!--<a href="javascript:;" class="mdui-btn mdui-btn-icon"><i class="mdui-icon material-icons">search</i></a>-->
                <a href="/" title="Kalzn" class="mdui-btn mdui-btn-icon"><img src="/static/pic/fiska_taluo.png" alt="Kalzn"></a>
            </div>
        </div>
    </div>
    <div id="nexmoe-header">
        <div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="Kalzn">
            <img src="/static/pic/fiska_taluo.png" alt="Kalzn" alt="Kalzn">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>19</div>
        <div><span>标签</span>13</div>
        <div><span>分类</span>7</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/archives.html" title="博客归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                博客归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35802619" title="CSDN博客">
            <i class="mdui-list-item-icon nexmoefont icon-ellipsis"></i>
            <div class="mdui-list-item-content">
                CSDN博客
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/img_src" title="戳我看荧">
            <i class="mdui-list-item-icon nexmoefont icon-tuchong"></i>
            <div class="mdui-list-item-content">
                戳我看荧
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/2022/11/19/hello-world/" title="博客迁移说明">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                博客迁移说明
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/2024/11/26/about-me/" title="关于博主">
            <i class="mdui-list-item-icon nexmoefont icon-info-circle"></i>
            <div class="mdui-list-item-content">
                关于博主
            </div>
        </a>
        
    </div>
    <aside id="nexmoe-sidebar">
    
        
        <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
        
            <form id="search_form">
                <label><input class="st-default-search-input" id="search_value" name="q" type="search" placeholder="搜索" style="
                    font-size: 15px !important;
                    height: 56px !important;
                    background-image: none;
                "></label>
            </form>
         
    </div>
</div>


	<script async src="/js/search.js?v=1732680051086"></script>



    
        
        <div class="nexmoe-widget-wrap">
	<div class="nexmoe-widget nexmoe-social">
		<a
			class="mdui-ripple"
			href="https://space.bilibili.com/28967505"
			target="_blank"
			mdui-tooltip="{content: '哔哩哔哩'}"
			style="
				color: rgb(231, 106, 141);
				background-color: rgba(231, 106, 141, .1);
			"
		>
			<i
				class="nexmoefont icon-bilibili"
			></i> </a
		><a
			class="mdui-ripple"
			href="https://github.com/Kalzncc"
			target="_blank"
			mdui-tooltip="{content: 'GitHub'}"
			style="
				color: rgb(25, 23, 23);
				background-color: rgba(25, 23, 23, .1);
			"
		>
			<i
				class="nexmoefont icon-github"
			></i> </a
		><a
			class="mdui-ripple"
			href="https://www.zhihu.com/people/ai-te-meyi-xia"
			target="_blank"
			mdui-tooltip="{content: '知乎'}"
			style="
				color: rgb(30, 136, 229);
				background-color: rgba(30, 136, 229, .1);
			"
		>
			<i
				class="nexmoefont icon-zhihu"
			></i> </a
		>
	</div>
</div>

    
        
        
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章分类</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/AI/">AI</a>
          <span class="category-list-count">4</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/八股/">八股</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/博客改造/">博客改造</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/工程/">工程</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/杂文/">杂文</a>
          <span class="category-list-count">3</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/算法竞赛/">算法竞赛</a>
          <span class="category-list-count">4</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/项目/">项目</a>
          <span class="category-list-count">1</span>
        </li>

        
      </ul>

    </div>
  </div>


    
        
        
  <div class="nexmoe-widget-wrap">
    <div id="randomtagcloud" class="nexmoe-widget tagcloud nexmoe-rainbow">
      <a href="/tags/ICPC/" style="font-size: 16.67px;">ICPC</a> <a href="/tags/oj/" style="font-size: 10px;">oj</a> <a href="/tags/python/" style="font-size: 10px;">python</a> <a href="/tags/%E5%85%AB%E8%82%A1/" style="font-size: 16.67px;">八股</a> <a href="/tags/%E5%8D%9A%E5%AE%A2/" style="font-size: 10px;">博客</a> <a href="/tags/%E5%9B%BE%E8%AE%BA/" style="font-size: 10px;">图论</a> <a href="/tags/%E5%B7%A5%E5%85%B7/" style="font-size: 10px;">工具</a> <a href="/tags/%E6%80%BB%E7%BB%93/" style="font-size: 16.67px;">总结</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">数据结构</a> <a href="/tags/%E6%95%B0%E8%AE%BA/" style="font-size: 10px;">数论</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 20px;">机器学习</a> <a href="/tags/%E7%BD%AE%E9%A1%B6/" style="font-size: 13.33px;">置顶</a> <a href="/tags/%E8%93%9D%E6%A1%A5/" style="font-size: 10px;">蓝桥</a>
    </div>
    
      <script>
        var maxTagcloud = parseInt(17);
        var tags_length = parseInt(13);
        var tags_arr = [];
        for(var i = 0; i < tags_length; i++){
          tags_arr.push(i);
        }
        tags_arr.sort(function (l, r) {
          return Math.random() > 0.5 ? -1 : 1;
        });
        tags_arr = tags_arr.slice(0, maxTagcloud < tags_length ? tags_length - maxTagcloud : 0);
        for(var tag_i = 0; tag_i < tags_arr.length; tag_i++){
          document.getElementById("randomtagcloud").children[tags_arr[tag_i]].style.display = 'none';
        }
      </script>
    
  </div>

    
        
        
        
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章归档</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/">2024</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/">2023</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/">2021</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/">2020</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>



    
        
        
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">最新文章</h3>
    <div class="nexmoe-widget">
      <ul>
        
          <li>
            <a href="/2024/11/27/csdn2local/">Csdn2Local:将csdn的博客保存到本地markdown格式</a>
          </li>
        
          <li>
            <a href="/2024/11/26/se-dm/">软件工程与设计模式相关，Spring简介</a>
          </li>
        
          <li>
            <a href="/2024/11/26/about-me/">关于我</a>
          </li>
        
          <li>
            <a href="/2024/04/09/137570823/">面试-数据库基础以及MySql、ClickHost、Redis简介</a>
          </li>
        
          <li>
            <a href="/2023/01/02/2022-final-blog/">2022最终回！</a>
          </li>
        
      </ul>
    </div>
  </div>

    
        
        <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-link">
		<ul>
        
            <li>
                <a href="https://www.squirt1e.top/" target="_blank" >
                    <img src="/static/yjl.png" alt="Squirt1e(某CTF佬)"></img>
                    <p>Squirt1e(某CTF佬)</p>
                </a>
            </li>
        
            <li>
                <a href="https://wu3227834.github.io/" target="_blank" >
                    <img src="/static/wdj.png" alt="小布丁(某测试佬)"></img>
                    <p>小布丁(某测试佬)</p>
                </a>
            </li>
        
		</ul>
    </div>
</div>
<style>
.nexmoe-widget-wrap .nexmoe-link ul li a {
    text-align : center;
}
.nexmoe-widget-wrap .nexmoe-link ul li a img {
    max-width : 100%;
}
.nexmoe-widget-wrap .nexmoe-link ul li a p {
    margin: 10px 0;
}
</style>

    
</aside>
    <div class="nexmoe-copyright">
        &copy; 2024 Kalzn
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        <span id="busuanzi_container_site_pv"> 本站总访问量<span id="busuanzi_value_site_pv"></span>次 </span><span id="busuanzi_container_site_uv"> 本站访客数<span id="busuanzi_value_site_uv"></span>人次 </span>
    </div>
</div><!-- .nexmoe-drawer -->
    </div>
    <div id="nexmoe-content">
        <div class="nexmoe-primary">
            <div class="nexmoe-post">

  <article>
    
        <div class="nexmoe-post-cover absolute" style="padding-top: NaN%;"> 
            <img src="/static/pic/ai/5.jpg" alt="面试-数据库基础以及MySql、ClickHost、Redis简介" loading="lazy">
            <h1>面试-数据库基础以及MySql、ClickHost、Redis简介</h1>
        </div>
    
    
    <div class="nexmoe-post-meta">
    <div class="nexmoe-rainbow">
        <a class="nexmoefont icon-calendar-fill">2024年04月09日</a>
        
            <a class="nexmoefont icon-appstore-fill -link" href="/categories/%E5%85%AB%E8%82%A1/">八股</a>
        
        

        <!-- 添加label列举 -->
        <div class="nexmoe-post-meta nexmoe-rainbow">
   
    
        <a class="nexmoefont icon-tag-fill -none-link" href="/tags/%E5%85%AB%E8%82%A1/" rel="tag">八股</a>
    
</div>

    </div>
    
    
    
    
    

</div>

    <h2 id="数据完整性">0.数据完整性</h2>
<p>确保数据准确和一致，主要有以下四类约束：</p>
<p><strong>实体完整性</strong> 主键完整</p>
<p><strong>域完整性</strong> 键值数据类型</p>
<p><strong>参照完整性</strong> 外键完整</p>
<p><strong>用户定义的完整性</strong> 例如计数器必须大于0等用户自定义的完整性条件# 面试-数据库基础、MySql、ClickHost、Redis简介</p>
<h2 id="数据库并发控制">1.数据库并发控制</h2>
<h3 id="事物">1.1事物</h3>
<p>事物是提交给DBMS执行的一系列操作。DBMS需要确保事物的操作序列被完整执行。即要么全部执行，要么回滚至事物执行前的状态，不能执行一半。</p>
<p>四大特性（ACID）：</p>
<p><strong>原子性（Atomicity）</strong> 事物的操作序列要么全部执行完毕，要么不执行。</p>
<p><strong>一致性（Consistency）</strong> 不能破坏数据库数据的完整性和一致性。</p>
<p><strong>隔离性（Isolation）</strong> 事物执行不能相互干扰。</p>
<p><strong>持久性（Durability）</strong> 事物一旦被提交，即被永久记录。</p>
<h3 id="并发读写错误">1.2 并发读写错误</h3>
<p><strong>更新丢失</strong> 事物A，B同时读取V，并都进行修改。那么第一个修改会丢失。</p>
<p><strong>读脏数据</strong> 事物A要对V值进行修改，但是事物B在此期间（事物A还没有来得及修改V之前）读取了V。然后在没有修改的V上进行计算，将错误结果存回。</p>
<figure>
<img onerror="imgOnError(this);" data-fancybox="gallery" src=".\54698ada292a8595409ddb45fccf66df.png" alt="" data-caption="" loading="lazy"><figcaption>在这里插入图片描述</figcaption>
</figure>
<p><strong>不可重复读</strong> 事物A先后读取两次V值，但是再次期间V被另一事物B修改，导致两次读取的V值不同。 <img onerror="imgOnError(this);" data-fancybox="gallery" src=".\104c6a52604180a5e89786a9c95b310a.png" alt="在这里插入图片描述" data-caption="在这里插入图片描述" loading="lazy"></p>
<p><strong>幻读</strong> 事物A在查询或统计某条或者数条记录，但再次期间事物B删除了该条或者删加了几条需要统计的记录，导致事物A再次读取时发生变化。（幻读强调数据的删除和增添，不可重读强调对数据内容的修改。） <img onerror="imgOnError(this);" data-fancybox="gallery" src=".\5123418bc1f4f3ffad7940310477ea48.png" alt="在这里插入图片描述" data-caption="在这里插入图片描述" loading="lazy"></p>
<h3 id="锁">1.3 锁</h3>
<h4 id="乐观锁与悲观锁">1.3.1 乐观锁与悲观锁</h4>
<p><strong>悲观锁</strong> 指的是在操作数据的时候比较悲观，悲观地认为别人一定会同时修改数据，因此悲观锁在操作数据时是直接把数据上锁，直到操作完成之后才会释放锁，在上锁期间其他人不能操作数据。</p>
<p><strong>乐观锁</strong> 指的是在操作数据的时候非常乐观，乐观地认为别人不会同时修改数据，因此乐观锁默认是不会上锁的，只有在执行更新的时候才会去判断在此期间别人是否修改了数据，如果别人修改了数据则放弃操作，否则执行操作。</p>
<h4 id="共享锁和排他锁">1.3.2 共享锁和排他锁</h4>
<p>共享锁（Share Locks，简记为S）又被称为读锁，其他用户可以并发读取数据，但任何事务都不能获取数据上的排他锁，直到已释放所有共享锁。</p>
<p>排它锁（(Exclusive lock,简记为X锁)）又称为写锁，若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。它防止任何其它事务获取资源上的锁，直到在事务的末尾将资源上的原始锁释放为止。在更新操作(INSERT、UPDATE 或 DELETE)过程中始终应用排它锁。</p>
<p><strong>写锁所有等，写锁等所有，读锁可共入</strong></p>
<h4 id="行锁与表锁">1.3.3 行锁与表锁</h4>
<p>见5.1.2</p>
<h4 id="意向锁">1.3.4 意向锁</h4>
<p>见5.1.2</p>
<h3 id="封锁协议与隔离级别">1.4 封锁协议与隔离级别</h3>
<p>S锁（共享锁 读锁）X锁（排他锁 写锁）</p>
<p><strong>一级封锁 对应 READ-UNCOMMITTED (读取未提交</strong> )</p>
<p>在修改数据A之前加X锁，事物结束释放。</p>
<p><strong>二级封锁 对应 READ-COMMITTED(读取已提交)</strong></p>
<p>在一级封锁的基础上，在读取A之前加S锁，读完释放。 （Oracle 默认隔离级别）</p>
<p><strong>三级封锁 对应 REPEATABLE-READ(可重复读)</strong></p>
<p>在一级封锁的基础上，在读取A之前加S锁，事物结束释放。（MySql 5.5 InnoDB 默认隔离级别）</p>
<p><strong>最高封锁 对应 SERIALIZABLE(可串行化 )</strong></p>
<p>最高的隔离级别，完全服从 ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产⽣干扰</p>
<table>
<thead>
<tr class="header">
<th></th>
<th>更新丢失</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>一级</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>二级</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>三级</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr class="even">
<td>最高</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody>
</table>
<h3 id="mvcc">1.5 MVCC</h3>
<h3 id="概念">1.5.1 概念</h3>
<p><code>MVCC</code>，全称<code>Multi-Version Concurrency Control</code>，即多版本并发控制。MVCC是一种并发控制的方法，是现代数据库（包括 MySQL、<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=Oracle&amp;spm=1001.2101.3001.7020">Oracle</a>、PostgreSQL 等）引擎实现中常用的处理读写冲突的手段，目的在于提高数据库高并发场景下的吞吐性能。</p>
<p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=MVCC&amp;spm=1001.2101.3001.7020">MVCC</a>用更好的方式去处理读—写请求，做到在发生读—写请求冲突时不用加锁。 这个读是指的快照读，而不是当前读，当前读是一种加锁操作，是悲观锁。</p>
<p>最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，<strong>只有写写之间相互阻塞，其他三种操作都可以并行</strong>，这样大幅度提高了InnoDB的并发度。</p>
<h4 id="当前读与快照读">1.5.2 当前读与快照读</h4>
<p>1.3提及的共享锁和排他锁都是<strong>当前锁</strong>。为什么叫当前读？就是它读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。</p>
<p><strong>当前读的实现方式：next-key锁(行记录锁+Gap间隙锁) 见4.1.2详细解释</strong></p>
<p>间隙锁：只有在Read Repeatable、Serializable隔离级别才有，就是锁定范围空间的数据，假设id有3,4,5，锁定id&gt;3的数据，是指的4，5及后面的数字都会被锁定，因为此时如果不锁定没有的数据，例如当加入了新的数据id=6，就会出现幻读，间隙锁避免了幻读。</p>
<p><strong>快照读</strong>是数据库操作中的一种读取方式，它指的是从数据库中获取在某个时间点或事务开始之前的数据快照。与当前读不同，快照读不会看到其他事务已经提交的更改，而是提供了一个固定时间点的数据库状态。这种读取方式通常用于需要查看历史数据或生成报表的应用场景。</p>
<p><strong>当前读/快照读与MVCC的关系</strong></p>
<p>MVCC是设计理念：保存数据的多个版本，使得读写操作没有冲突。</p>
<p>快照读是MySql（InnoDB引擎）为了实现MVCC模型的一种具体的做法。</p>
<h4 id="mvcc-in-innodb">1.5.3 MVCC in InnoDB</h4>
<p>MVCC的目的就是多版本并发控制，在数据库中的实现，就是为了解决<code>读写冲突</code>，它的实现原理主要是依赖记录中的 <code>3个隐式字段</code>。<code>undo日志</code> ，<code>Read View</code> 来实现MVCC。</p>
<p>Undolog：处理修改和回滚</p>
<p>Read View：处理读取时的快照生成</p>
<p><strong>Undolog</strong></p>
<p>事务会先使用“排他锁”锁定改行，将该行当前的值复制到undo log中，然后再真正地修改当前行的值，最后填写事务的<strong>DB_TRX_ID</strong>，使用回滚指针<strong>DB_ROLL_PTR</strong>指向undo log中修改前的行<strong>DB_ROW_ID</strong>。</p>
<figure>
<img onerror="imgOnError(this);" data-fancybox="gallery" src=".\690f6ec72aa19755b847da70893f30bd.png" alt="" data-caption="" loading="lazy"><figcaption>在这里插入图片描述</figcaption>
</figure>
<p><strong>DB_TRX_ID</strong>: 6字节<code>DB_TRX_ID</code>字段，表示最后更新的事务id(update,delete,insert)。此外，删除在内部被视为更新，其中行中的特殊位被设置为将其标记为已软删除。</p>
<p><strong>DB_ROLL_PTR</strong>: 7字节回滚指针，指向前一个版本的undolog记录，组成undo链表。如果更新了行，则撤消日志记录包含在更新行之前重建行内容所需的信息。</p>
<p><strong>DB_ROW_ID</strong>: 6字节的DB_ROW_ID字段，包含一个随着新行插入而单调递增的行ID, 当由innodb自动产生聚集索引时，聚集索引会包括这个行ID的值，否则这个行ID不会出现在任何索引中。如果表中没有主键或合适的唯一索引, 也就是无法生成聚簇索引的时候, InnoDB会帮我们自动生成聚集索引, 聚簇索引会使用DB_ROW_ID的值来作为主键; 如果表中有主键或者合适的唯一索引, 那么聚簇索引中也就不会包含 DB_ROW_ID了 。</p>
<p><strong>Read View</strong></p>
<p>说白了Read View就是事务进行<code>快照读</code>操作的时候生产的<code>读视图</code>(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃事务的ID(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)。</p>
<p><code>Read View</code>遵循一个可见性算法，主要是将<code>要被修改的数据</code>的最新记录中的<code>DB_TRX_ID</code>（即当前事务ID）取出来，与系统当前其他活跃事务的ID去对比（由Read View维护），如果<code>DB_TRX_ID</code>跟Read View的属性做了某些比较，不符合可见性，那就通过<code>DB_ROLL_PTR</code>回滚指针去取出<code>Undo Log</code>中的<code>DB_TRX_ID</code>再比较，即遍历链表的<code>DB_TRX_ID</code>（从链首到链尾，即从最近的一次修改查起），直到找到满足特定条件的<code>DB_TRX_ID</code>, 那么这个DB_TRX_ID所在的旧记录就是当前事务能看见的最新<code>老版本</code></p>
<h2 id="数据库范式">2. 数据库范式</h2>
<p><strong>目的</strong>：消除冗余</p>
<p><strong>第一范式（1NF）</strong> 属性不可分（关系数据库的基础）</p>
<p><strong>第二范式（2NF）</strong> 在1NF的基础上，不存在部分依赖，非主键列要完全依赖于主键。</p>
<p>例如：为了记录学生成绩，有属性studentID，studnetName，courseID，courseName，score。其中studnetName仅依赖studentID；courseName仅依赖courseID，而主键为(studentID, courseID)。所以将上述记录存储在一张表里不符合2NF。正确做法是拆分3张表存储：学生表：（studentID，studentName），课程表：（courseID，courseName），分数表：（studentID，courseID，score）。</p>
<p><strong>第三范式（3NF）</strong> 在2NF的基础上，不存在传递依赖。</p>
<p>例如：记录人员：有属性：name，sexCode，sexText</p>
<p>其中sexCode依赖name，而sexText依赖sexCode。所以将上述记录存储在一张表里不符合3NF。正确做法是拆分2张表存储：人员表：（name，sexCode），性别表：（sexCode，sexText）。</p>
<p><strong>BC范式（BCNF）</strong> 在3NF的基础上，关系R中的每个非平凡函数依赖X → Y，X必须是R的超键。</p>
<p>例如仓库管理（仓库号，存储物品号，管理员号，数量）满足一个管理员只在一个仓库工作；一个仓库可以存储多种物品，则存在如下关系：</p>
<p>(仓库号，存储物品号)——&gt;(管理员号，数量)</p>
<p>(管理员号，存储物品号)——&gt;(仓库号，数量)</p>
<p>但是(仓库号)——&gt;(管理员号)且(管理员号)——&gt;(仓库号)。即存在关键字段决定关键字段的情况，因此其不符合BCNF。把仓库管理关系表分解为两个关系表仓库管理表(仓库号，管理员号)和仓库表(仓库号，存储物品号，数量)，这样这个数据库表是符合BCNF的，并消除了删除异常、插入异常和更新异常。</p>
<p><strong>第四范式（4NF）</strong></p>
<p>设R是一个关系模型，D是R上的多值依赖集合。如果D中存在凡多值依赖X-&gt;Y时，X必是R的超键，那么称R是第四范式的模式。</p>
<p>例如，职工表(职工编号，职工孩子姓名，职工选修课程)，在这个表中，同一个职工可能会有多个职工孩子姓名，同样，同一个职工也可能会有多个职工选修课程，即这里存在着多值事实，不符合第四范式。如果要符合第四范式，只需要将上表分为两个表，使它们只有一个多值事实，例如职工表一(职工编号，职工孩子姓名)，职工表二(职工编号，职工选修课程)，两个表都只有一个多值事实，所以符合第四范式。</p>
<p><strong>数据库范式只是理论指导规范，遵不遵守要看工程的实际情况。工程上多有为了效率而牺牲空间的例子，这些情况下数据库甚至可能不符合1NF。</strong></p>
<p>此外还有BCNF、4NF直至5NF。这些范式的强度依次增强，冗余越低。</p>
<h2 id="分布式系统cap定理">3.分布式系统CAP定理</h2>
<p>CAP定理是分布式系统中的一个基本定理，它指出任何分布式系统最多可以具有以下三个属性中的两个。</p>
<p><strong>一致性（Consistency）</strong></p>
<p>在一个一致性的系统中，客户端向任何服务器发起一个写请求，将一个值写入服务器并得到响应，那么之后向任何服务器发起读请求，都必须读取到这个值(或者更加新的值)。</p>
<p><strong>可用性（Availability）</strong></p>
<p>在一个可用的分布式系统中，客户端向其中一个服务器发起一个请求且该服务器未崩溃，那么这个服务器最终必须响应客户端的请求。</p>
<p><strong>分区容错性（Partition tolerance）</strong></p>
<p>能容忍网络分区，在网络断开的情况下，被分隔的节点仍能正常对外提供服务。</p>
<p><strong>CA</strong> 保证一致性和可用性，所有服务器必须互相通信才可以。所以丧失P属性。</p>
<p><strong>CP</strong> 在网络分区（服务器无法通信）的情况下，为了保证C属性，只等设定一组服务器上的副本为可用的，其他分区的服务器为不可用，所以丧失A属性。</p>
<p><strong>AP</strong> 在网络分区（服务器无法通信）且所有服务器都保证可用的情况下，无法保证数据一致，丧失C属性。</p>
<h2 id="灾备">4.灾备</h2>
<p><strong>RAID0 （不含校验码的条带存储）</strong></p>
<p>RAID 0 又称为Stripe（条带化），它在所有RAID级别中具有最高的存储性能，通过多块磁盘组合为RAID 0后，数据被分割并分别存储在每块硬盘中，所以能最大程度的提升存储性能与存储空间，把连续的数据分散到多个磁盘上存取，这样，系统有数据请求就可以被多个磁盘并行的执行，每个磁盘执行属于它自己的那部分数据请求，这种数据上的并行操作可以充分利用总线的带宽，显著提高磁盘整体存取性能，但是无法容错。</p>
<p>优：速度快、无冗余、读写并行、磁盘利用率100%。</p>
<p>缺：没有备份，没有灾备能力。</p>
<p><strong>RAID 1 （不含校验码的镜像存储）</strong></p>
<p>RAID 1 又称为Mirror 或Mirrooring(镜像)，它的宗旨是最大限度的保证用户数据的可用性和可修复性，RAID 1 的操作方式是把用户写入硬盘的数据百分之百的自动复制到另外一个硬盘上，从而实现存储双份的数据。</p>
<p>优：保证了数据冗余，保证了数据安全，可靠性高，可以并发读取（相当于两块RAID 0）。</p>
<p>缺：写入效率低下，磁盘利用率低。</p>
<p><strong>RAID 5 （数据块级别的分布式校验条带存储）</strong></p>
<p>RAID 5 是一种存储性能，数据安全和存储成本兼顾的存储解决方案。RAID5技术是把硬盘设备的数据奇偶校验信息保存到其他硬盘设备中。RAID5磁盘阵列组中数据的奇偶校验信息并不是单独保存到某一块磁盘设备中，而是存储到除自身以外的其他每一块对应的磁盘上，这样的好处是其中任何一个磁盘损坏后不至于出现致命缺陷，但只能允许一块磁盘损坏，否则无法利用剩下的数据和校验信息进行数据的恢复。</p>
<p>优：RAID0和RAID1的折中，兼顾存储性能、数据安全和存储成本。</p>
<p>缺：写入性能相对较差，而且只允许单磁盘故障，在有磁盘离线的情况下，RAID 5 的读写性能较差，在重建数据时，性能会受到较大的影响。</p>
<p><strong>RAID 6 （两种存储的奇偶校验码的磁盘结构）</strong></p>
<p>RAID6技术是在RAID 5基础上，为了进一步加强数据保护而设计的一种RAID方式，实际上是一种扩展RAID 5等级。与RAID 5的不同之处于除了每个硬盘上都有同级数据XOR校验区外，还有一个针对每个数据块的XOR校验区。与RAID 5 相同的是当前磁盘数据块的校验数据不可能存在当前磁盘中，而是交错存储的。组建RAID 6 要求至少4块硬盘，而RAID 6可以允许坏掉两块硬盘。</p>
<p>优：RAID 6的数据冗余性能相当好，在使用大数据块时，随机读取性能好，允许两块硬盘的掉线，有更高的容错能力。</p>
<p>缺：由于增加了一个校验，所以写入的效率比RAID 5还差，而且RAID控制系统的设计也更为复杂，第二块的校验区也减少了硬盘有效存储空间。</p>
<p><strong>RAID 10（镜像与条带存储）</strong></p>
<p>RAID 10 不是独创的一种RAID级别，它由RAID 1 和 RAID 0 两种阵列形式组合而成，RAID 10继承了RAID 0 的快速与高效，同时也继承了RAID 1 的数据安全，RAID 10 至少需要四块硬盘。RAID 1+0，先使用四块硬盘组合成两个独立的RAID 1 ，然后将两个RAID 1 组合成一个RAID 0。</p>
<p>优: RAID10兼备了RAID1和RAID0的优点，不仅实现了数据保障的作用，也保障数据读写的效率。</p>
<p>缺: 由于一半的磁盘空间都用于存储冗余数据，所以RAID 10的磁盘利用率很低，只有50%。</p>
<p><strong>RAID 50</strong></p>
<p>RAID50是RAID5与RAID0的结合。此配置在RAID5的子磁盘组的每个磁盘上进行包括奇偶信息在内的数据的剥离。每个RAID5子磁盘组要求至少三个硬盘。RAID50具备更高的容错能力，因为它允许某个组内有一个磁盘出现故障，而不会造成数据丢失。</p>
<p>优： 比RAID5有更好的读性能，比相同容量的RAID5重建时间更短，可以容许N个磁盘同时失效，更高的容错能力，具备更快数据读取速率的潜力。</p>
<p>缺： 设计复杂，比较难实现；同一个RAID5组内的两个磁盘失效会导致整个阵列失效；磁盘故障会影响吞吐量。故障后重建信息的时间比镜像配置情况下要长。</p>
<figure>
<img onerror="imgOnError(this);" data-fancybox="gallery" src=".\781a6f0e50f9584b4362c930bd445af1.png" alt="" data-caption="" loading="lazy"><figcaption>在这里插入图片描述</figcaption>
</figure>
<h2 id="mysql数据库框架与引擎">5.Mysql数据库框架与引擎</h2>
<h3 id="mysql-framework">5.1 Mysql Framework</h3>
<h4 id="框架">5.1.1 框架</h4>
<figure>
<img onerror="imgOnError(this);" data-fancybox="gallery" src=".\c108db1eb3d0832963d01dabbf5c934f.png" alt="" data-caption="" loading="lazy"><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>MySQL 可以分为 Server 层和存储引擎两部分。</p>
<p><strong>Server 层</strong>包括：连接器、查询缓存、分析器、优化器、执行器等，涵盖了 MySQL 的大多数核心服务功能，以及所有的内置函数（如：日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这⼀层实现，比如：存储过程、触发器、视图等等。 <strong>存储引擎层</strong>负责：数据的存储和提取。其架构是插件式的，⽀持 InnoDB 、 MyISAM 等多个存储引擎。从 MySQL5.5.5 版本开始默认的是 InnoDB ，但是在建表时可以通过 engine = MyISAM 来指定存储引擎。不同存储引 擎的表数据存取方式不同，支持的功能也不同。</p>
<h4 id="innodb-myisam">5.1.2 InnoDB &amp; MyISAM</h4>
<p>MyISAM是 MySQL 的默认数据库引擎（ 5.5版之前）。虽然性能极佳，而且提供了大量的特性， 包括全文索引、压缩、空间函数等，但 MyISAM不支持事务和行级锁，而且最⼤的缺陷就是崩溃后无法安全恢复。不过， 5.5 版本之后， MySQL 引入了 InnoDB （事务性数据库引擎），MySQL5.5 版本后默认的存储引擎为 InnoDB 。 <strong>InnoDB vs MyISAM</strong></p>
<ol type="1">
<li><p><strong>是否支持行锁</strong> MyISAM只有表锁，InnoDB支持行锁和表锁，默认为行锁。</p></li>
<li><p><strong>是否支持事务</strong> MyISAM不提供事物支持，InnoDB支持。同时，InnoDB具备rollback、crash recovery能力。</p></li>
<li><p><strong>是否支持外键</strong> MyISAM不支持，InnoDB支持。</p></li>
<li><p><strong>是否支持MVCC</strong> 仅InnoDB支持。</p></li>
</ol>
<p><strong>总之一句话：MyISAM注重效率，而InnoDB更意图保证并行下的数据完整性</strong></p>
<h3 id="lock-in-mysql">5.2 Lock in Mysql</h3>
<p>InnoDB中支持表锁和行锁，而MyISAM仅支持表锁。InnoDB中的表锁和行锁都分为S锁和X锁。</p>
<p><strong>表锁</strong></p>
<p>Mysql中锁定 粒度最大 的一种锁，对当前操作的整张表加锁，实现简单 ，资源消耗也比较少，加锁快，不会出现死锁 。此外表锁还存在意向锁：</p>
<p>而意向锁的作用就是当一个事务在需要获取资源锁定的时候，如果遇到自己需要的资源已经被排他锁占用的时候，该事务可以在需要锁定行的表上面添加一个合适的意向锁。如果自己需要一个共享锁，那么就在表上面添加一个意向共享锁。而如果自己需要的是某行（或者某些行）上面添加一个排他锁的话，则先在表上面添加一个意向排他锁。意向共享锁可以同时并存多个，但是意向排他锁同时只能有一个存在。</p>
<ol type="1">
<li><p><strong>意向共享锁（IS）：</strong> 表示事务准备给数据行记入共享锁，事务在一个数据行加共享锁前必须先取得该表的IS锁。</p></li>
<li><p><strong>意向排他锁（IX）：</strong> 表示事务准备给数据行加入排他锁，事务在一个数据行加排他锁前必须先取得该表的IX锁。</p></li>
</ol>
<p>意向锁vs普通锁：意向锁是放置在资源层次结构的一个级别上的锁，如果想要下级资源（如表中的行）加锁，则需要先将上级资源加上意向锁。（把资源层级看作一棵树，要给某个节点加锁，则其祖先必须先加意向锁。）如果一个上级资源被加了意向锁，则证明某下级资源被加锁。</p>
<p><strong>行锁</strong></p>
<p>Mysql中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</p>
<ol type="1">
<li><p><strong>Record Lock</strong> 对索引项加锁，锁定符合条件的行。其他事务不能修改和删除加锁项</p></li>
<li><p><strong>Gap Lock</strong> 对索引项之间的“间隙”加锁，锁定记录的范围（对第一条记录前的间隙或最后一条将记录后的间隙加锁）。（即在两个索引之前加锁）</p></li>
<li><p><strong>Next-key Lock</strong> 锁定索引项本身和索引范围。即Record Lock和Gap Lock的结合。可解决幻读问题。</p></li>
</ol>
<h3 id="数据库索引">5.3 数据库索引</h3>
<h4 id="聚簇索引innodb和非聚簇索引myisam">5.3.1 聚簇索引（InnoDB）和非聚簇索引（MyISAM）</h4>
<p><strong>聚簇索引</strong> 将<strong>数据</strong>存储与<strong>索引</strong>放到了一块，索引结构的<strong>叶子节点</strong>保存了<strong>行数据</strong>。表数据按照索引的顺序来存储的，也就是说索引项的顺序与表中记录的物理顺序一致。它默认的实现是这个主键索引。主键索引就是聚簇索引他实现之一，如果你这个表里没有这个主键索引，InnoDB就会选择一个唯一的非空索引代替。 如果连唯一的索引都没有的话，这个InnoDB就会在内部生成一个隐式的聚簇索引。</p>
<p><strong>非聚簇索引</strong> 将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置。</p>
<p>InnnDB中，会在主键建立聚簇索引。当在其他键建立索引时，InnoDB是这么干的：建立一个二级索引，这个索引可以通过其他建值索引到主键，然后在使用主键再索引数据。</p>
<p>在MyISAM中，采用非聚簇索引，即索引的叶子节点是行指针，指向对应的行。</p>
<figure>
<img onerror="imgOnError(this);" data-fancybox="gallery" src=".\470545716923b12e64ba9512c4379a22.png" alt="" data-caption="" loading="lazy"><figcaption><img onerror="imgOnError(this);" data-fancybox="gallery" src="file:///C:/Users/22612/AppData/Roaming/marktext/images/2024-04-08-17-20-34-image.png" alt="" data-caption="" loading="lazy"></figcaption>
</figure>
<p><strong>聚簇索引 vs 非聚簇索引</strong></p>
<p>聚簇索引优点：</p>
<ol type="1">
<li><p>快速数据访问：由于数据物理存储顺序与索引顺序一致，相邻数据行通常存储在同一磁盘块中，减少了I/O操作次数，提高了查询速度。</p></li>
<li><p>高效存储：聚簇索引的叶子节点存储的是数据行本身，对于不需要查询全部列的查询语句，可以减少I/O操作，提高查询效率。</p></li>
<li><p>排序查找快速：对于主键的排序查找和范围查找，聚簇索引表现出色。</p></li>
</ol>
<p>聚簇索引缺点：</p>
<ol type="1">
<li><p>插入和更新性能：插入和更新数据时需要移动其他数据行，这可能导致性能下降。</p></li>
<li><p>数据访问局限性：如果数据不是按照索引顺序存储的，某些数据访问可能会较慢。</p></li>
<li><p>主键更新代价高：更新主键时，需要移动被更新的行，这可能导致性能下降。</p></li>
</ol>
<p>非聚簇索引优点：</p>
<ol type="1">
<li><p>插入和更新效率：插入和更新数据时不需要移动数据，因此不会影响性能。</p></li>
<li><p>维护简单：在表的数据发生变化时，不需要重新组织索引结构，减少维护索引的时间。</p></li>
</ol>
<p>非聚簇索引缺点：</p>
<ol type="1">
<li>查询效率：查询时需要进行两次磁盘I/O操作：第一次查找索引条目，第二次查找实际数据行，这使得查询效率相对较低。</li>
</ol>
<p><strong>简而言之：聚簇索引查快改慢，非聚簇索引查慢改快</strong></p>
<h4 id="索引数据结构">5.3.2 索引数据结构</h4>
<p>MySQL索引使用的数据结构主要有 <strong>BTree</strong> <strong>索引</strong> 和 <strong>哈希索引</strong> 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree 索引。</p>
<p>MySQL的 BTree 索引使用的是 B 树中的 B+Tree，但对于主要的两种存储引擎的实现方式是不同的。</p>
<p>BTree和B+Tree以及散列表详细介绍见数据结构章节</p>
<p><strong>为什么MySql采用B+Tree而不是BTree</strong></p>
<p>用 B+ 树不用 B 树考虑的是 IO 对性能的影响， B 树的每个节点都存储数据，而 B+ 树只有叶子节点才存储数据，所 以查找相同数据量的情况下， B 树所需要的内存更大， IO 更频繁。数据库索引是存储在磁盘上的，当数据量大时，就不能把整个索引全部加载到内存了，只能逐⼀加载每⼀个磁盘页（对应索引树的节点）。 <strong>自适应哈希索引</strong></p>
<p>哈希索引能以 O(1) 时间进行查找，但是失去了有序性。无法用于排序与分组、只⽀持精确查找，无法用于部分查找和范围查找。InnoDB 存储引擎有⼀个特殊的功能叫 “<strong>自适应哈希索引</strong> ” ，当某个索引值被使用的非常频繁时，会在 B+ 树索引之上 再创建⼀个哈希索引，这样就让 B+Tree 索引具有哈希索引的⼀些优点，比如：快速的哈希查找。</p>
<p><strong>InnoDB B+树 可以存放多少行数据</strong></p>
<p>InnoDB的默认最小存储单位为16k。假设每条记录占用空间为1k。一个高度为2个B+Tree包括一个根节点（16k），在其中存储多项（主键+指针）的组合。由于InnoDB默认主键为bigint 8字节，指针为硬编码的6字节，所以每条记录为14字节。根节点共存储16384/14=1170个子节点指针。而叶子节点用于存储数据，前面假设每条记录为1k，所以一个节点可以存储16k/1k=16条数据。因此，高度为2的B+Tree共计存储1170 * 16 = 18720条记录。同理可知高度为3个B+Tree可存储1170* 1170 *16=21902400条记录。</p>
<p><strong>InnoDB单表最多可以存储多少数据</strong></p>
<ol type="1">
<li><p>自建主键的情况下取决于主键类型的最大值，例如主键为int(4)，那就是4字节int的最大值。如果超过则报错。</p></li>
<li><p>没有主键自动生成一个隐藏主键int(6)，如果超过则会覆盖之前的数据而不会报错。</p></li>
</ol>
<p><strong>B+Tree vs BTree</strong>（为什么MySql选择B+Tree而不是BTree？）</p>
<ul>
<li>B+树非叶子节点只存储key值，而B树存储key值和data值，这样B+树每次读取时可以读取到更多的key值。</li>
<li>mysql进行区间访问时，由于B+树叶子节点之间用指针相连，只需要遍历所有的叶子节点即可；而B树则需要中序遍历那样遍历</li>
<li>B+树非叶子节点只存储key值，而B树存储key值和data值，导致B+树的层级更少，查询效率更高</li>
<li>B+树所有关键词地址都存在叶子节点上，所以每次查询次数都相同，比B树稳定</li>
</ul>
<p><strong>B+Tree vs Hash</strong> （Hash明明更快O(1)，MySql为什么选择B+Tree而不是Hash？）</p>
<ol type="1">
<li><p><strong>磁盘IO特性</strong>：从内存角度上说，数据库中的索引一般时在磁盘上，数据量大的情况可能无法一次性装入内存，B+树的设计可以允许数据分批加载。</p></li>
<li><p><strong>Hash不适应多条范围查询</strong>：从业务场景上说，如果只选择一个数据那确实是hash更快，但是数据库中经常会选中多条这时候由于B+树索引有序，并且又有链表相连，它的查询效率比hash就快很多了。</p>
<p>MySql也支持Hash索引（默认是B+Tree），如前文所述，它仅在单条查询占比较大的情况下比较快。</p></li>
</ol>
<p><strong>B+Tree vs 红黑树</strong> （内存中，红黑树优于B+Tree。为什么Mysql选择B+Tree？）</p>
<ol type="1">
<li><strong>操作系统IO特性</strong>：操作系统所组织的文件系统最小单位为页，即使只需要该页内的部分数据，也需要整页读取。而红黑树是二叉树，仅有两个孩子节点，无法充分利用单页的存储空间。而B+Tree是多叉树，单节点可以挂载很多孩子，在充分利用单页存储空间的同时减少树的高度，减少了IO次数。</li>
</ol>
<p><strong>ps.有关hash、BTree、红黑树的详细介绍移步数据结构.md</strong></p>
<h4 id="索引分类总结">5.3.3 索引分类总结</h4>
<p>从数据结构角度：1）B+Tree索引O(logn) 2) Hash索引 O(1)</p>
<p>从物理存储角度：1）聚簇索引 2）非聚簇索引</p>
<h4 id="索引可用性">5.3.4 索引可用性</h4>
<p><strong>最左前缀原则</strong></p>
<p>最左前缀原则（Leftmost Prefix Rule）是索引在数据库查询中的一种使用规则。它指的是在使用复合索引时，查询条件需要遵循索引中列的顺序，从左到右进行匹配。只有当查询条件满足最左前缀原则时，才能充分利用联合索引的优势，提高查询性能。</p>
<p>例如索引组(a,b,c)。当查询(a,c)时，仅有a索引可以被利用，而由于b被跳过了，所以c索引无法被利用。</p>
<p>再例如，查询(b,c)时，所有索引均不会被利用，这是由于a被跳过了。形式来讲当存在索引组：</p>
<p><span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="19.011ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 8402.9 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D43C" d="M43 1Q26 1 26 10Q26 12 29 24Q34 43 39 45Q42 46 54 46H60Q120 46 136 53Q137 53 138 54Q143 56 149 77T198 273Q210 318 216 344Q286 624 286 626Q284 630 284 631Q274 637 213 637H193Q184 643 189 662Q193 677 195 680T209 683H213Q285 681 359 681Q481 681 487 683H497Q504 676 504 672T501 655T494 639Q491 637 471 637Q440 637 407 634Q393 631 388 623Q381 609 337 432Q326 385 315 341Q245 65 245 59Q245 52 255 50T307 46H339Q345 38 345 37T342 19Q338 6 332 0H316Q279 2 179 2Q143 2 113 2T65 2T43 1Z"></path></g><g data-mml-node="mi" transform="translate(504,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(1024,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(1413,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mn" transform="translate(562,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="mo" transform="translate(2378.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(2823.2,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mn" transform="translate(562,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(3788.8,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(4233.4,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mn" transform="translate(562,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(5199,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mo" transform="translate(5643.7,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g><g data-mml-node="mo" transform="translate(6088.3,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g><g data-mml-node="mo" transform="translate(6533,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g><g data-mml-node="msub" transform="translate(6977.7,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(562,-150) scale(0.707)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mo" transform="translate(8013.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span></p>
<p>而对于查询：</p>
<p><span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.666ex;" xmlns="http://www.w3.org/2000/svg" width="37.446ex" height="2.363ex" role="img" focusable="false" viewBox="0 -750 16551.3 1044.2"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D444" d="M399 -80Q399 -47 400 -30T402 -11V-7L387 -11Q341 -22 303 -22Q208 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435Q740 255 592 107Q529 47 461 16L444 8V3Q444 2 449 -24T470 -66T516 -82Q551 -82 583 -60T625 -3Q631 11 638 11Q647 11 649 2Q649 -6 639 -34T611 -100T557 -165T481 -194Q399 -194 399 -87V-80ZM636 468Q636 523 621 564T580 625T530 655T477 665Q429 665 379 640Q277 591 215 464T153 216Q153 110 207 59Q231 38 236 38V46Q236 86 269 120T347 155Q372 155 390 144T417 114T429 82T435 55L448 64Q512 108 557 185T619 334T636 468ZM314 18Q362 18 404 39L403 49Q399 104 366 115Q354 117 347 117Q344 117 341 117T337 118Q317 118 296 98T274 52Q274 18 314 18Z"></path></g><g data-mml-node="mi" transform="translate(791,0)"><path data-c="1D462" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1363,0)"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(1829,0)"><path data-c="1D45F" d="M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(2280,0)"><path data-c="1D466" d="M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(2770,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(3159,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mn" transform="translate(562,-150) scale(0.707)"><path data-c="30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path></g></g><g data-mml-node="mo" transform="translate(4124.6,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(4569.2,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mn" transform="translate(562,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(5534.8,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(5979.4,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mn" transform="translate(562,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(6945,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="mo" transform="translate(7389.7,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g><g data-mml-node="mo" transform="translate(7834.3,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g><g data-mml-node="mo" transform="translate(8279,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g><g data-mml-node="msub" transform="translate(8723.7,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mi" transform="translate(562,-150) scale(0.707)"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g></g><g data-mml-node="mo" transform="translate(9627,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(10071.7,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="TeXAtom" transform="translate(562,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mn" transform="translate(554,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></g><g data-mml-node="mo" transform="translate(11360.7,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(11805.4,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="TeXAtom" transform="translate(562,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mn" transform="translate(554,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g></g><g data-mml-node="mo" transform="translate(13094.5,0)"><path data-c="2C" d="M78 35T78 60T94 103T137 121Q165 121 187 96T210 8Q210 -27 201 -60T180 -117T154 -158T130 -185T117 -194Q113 -194 104 -185T95 -172Q95 -168 106 -156T131 -126T157 -76T173 -3V9L172 8Q170 7 167 6T161 3T152 1T140 0Q113 0 96 17Z"></path></g><g data-mml-node="msub" transform="translate(13539.2,0)"><g data-mml-node="mi"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="TeXAtom" transform="translate(562,-150) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mn" transform="translate(554,-150) scale(0.707)"><path data-c="33" d="M127 463Q100 463 85 480T69 524Q69 579 117 622T233 665Q268 665 277 664Q351 652 390 611T430 522Q430 470 396 421T302 350L299 348Q299 347 308 345T337 336T375 315Q457 262 457 175Q457 96 395 37T238 -22Q158 -22 100 21T42 130Q42 158 60 175T105 193Q133 193 151 175T169 130Q169 119 166 110T159 94T148 82T136 74T126 70T118 67L114 66Q165 21 238 21Q293 21 321 74Q338 107 338 175V195Q338 290 274 322Q259 328 213 329L171 330L168 332Q166 335 166 348Q166 366 174 366Q202 366 232 371Q266 376 294 413T322 525V533Q322 590 287 612Q265 626 240 626Q208 626 181 615T143 592T132 580H135Q138 579 143 578T153 573T165 566T175 555T183 540T186 520Q186 498 172 481T127 463Z"></path></g></g></g></g><g data-mml-node="mo" transform="translate(14828.3,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g><g data-mml-node="mo" transform="translate(15272.9,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g><g data-mml-node="mo" transform="translate(15717.6,0)"><path data-c="2E" d="M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z"></path></g><g data-mml-node="mo" transform="translate(16162.3,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></span></p>
<p>如果<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.486ex;" xmlns="http://www.w3.org/2000/svg" width="10.013ex" height="2.106ex" role="img" focusable="false" viewBox="0 -716 4425.6 931"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g><g data-mml-node="mo" transform="translate(689.8,0)"><path data-c="2260" d="M166 -215T159 -215T147 -212T141 -204T139 -197Q139 -190 144 -183L306 133H70Q56 140 56 153Q56 168 72 173H327L406 327H72Q56 332 56 347Q56 360 70 367H426Q597 702 602 707Q605 716 618 716Q625 716 630 712T636 703T638 696Q638 692 471 367H707Q722 359 722 347Q722 336 708 328L451 327L371 173H708Q722 163 722 153Q722 140 707 133H351Q175 -210 170 -212Q166 -215 159 -215Z"></path></g><g data-mml-node="msub" transform="translate(1745.6,0)"><g data-mml-node="mi"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g><g data-mml-node="mn" transform="translate(554,-150) scale(0.707)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g><g data-mml-node="mo" transform="translate(2925.3,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(3925.6,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g></svg></mjx-container></span>,则仅有前<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.462ex;" xmlns="http://www.w3.org/2000/svg" width="0.932ex" height="1.957ex" role="img" focusable="false" viewBox="0 -661 412 865"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D457" d="M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z"></path></g></g></g></svg></mjx-container></span>个索引可以被利用。</p>
<p>此外最左前缀碰到范围查询时也会停止！后面的索引都不会用到。</p>
<p><strong>如何知道创建的索引有没有被用到？或是说怎么排除语句运行慢的原因？</strong></p>
<p>使用 Explain 命令来查看语句的执行计划，MySQL 在执行某个语句之前，会将该语句过⼀遍查询优化器，之后会拿到对语句的分析，也就是执行计划，其中包含了许多信息。可以通过其中和索引有关的信息来分析是否命中了索引，例如： possilbe_key 、 key 、 key_len 等字段，分别说明了此语句可能会使用的索引、实际使用的索引以及使用的索引长度。</p>
<p><strong>会导致索引失效的情况？</strong></p>
<ol type="1">
<li><p>索引参与表达式或函数计算</p></li>
<li><p>通配符</p></li>
<li><p>字符串和数字比较无法利用索引</p></li>
<li><p>or语句中如果有一项没有索引，则另一项索引失效</p></li>
<li><p>正则</p></li>
<li><p>优化器判定全表扫描更快时不用索引</p></li>
</ol>
<p><strong>查询优化方案？</strong></p>
<ol type="1">
<li><p><strong>减少请求量</strong>：仅返回必要的列和行</p></li>
<li><p><strong>内存侧缓存</strong>：讲频繁查询的记录存储在内存中</p></li>
<li><p><strong>使用链接（join）而不是子查询</strong></p></li>
<li><p><strong>使用union而不是or</strong></p></li>
<li><p><strong>避免范围查询</strong>：甚少在where子句中使用!=, &lt;, &gt;</p></li>
<li><p><strong>避免null值判断</strong>：这会迫使引擎采用全表扫描而不是索引</p></li>
</ol>
<p><strong>索引优缺点</strong>（何时应该怎样应该建立索引？）</p>
<ol type="1">
<li><p>需要查询、排序、分组和联合操作的字段适合建立索引。</p></li>
<li><p>使用字段值不重复比例大的字段建立索引，联合索引比独立索引的效率高。</p></li>
<li><p>索引越多，维护成本越高，数据修改的效率越低。</p></li>
<li><p>唯一性索引可以确保数据唯一性。</p></li>
<li><p>索引可以加快表的链接效率，在实现参照完整性的方面具有特别意义。</p></li>
</ol>
<h3 id="主从复制">5.4 主从复制</h3>
<h4 id="概念-1">5.4.1 概念</h4>
<p>主从复制，是用来建立一个和主数据库完全一样的数据库环境，称为从数据库，主数据库一般是准实时的业务数据库。</p>
<h4 id="binlog">5.4.2 Binlog</h4>
<p>从比较宽泛的角度来探讨复制的原理，MySQL的Server之间通过二进制日志来实现实时数据变化的传输复制，这里的二进制日志是属于MySQL服务器的日志，记录了所有对MySQL所做的更改。这种复制模式也可以根据具体数据的特性分为三种：</p>
<ol type="1">
<li><p><strong>Statement：基于语句格式</strong></p>
<p>Statement模式下，复制过程中向获取数据的从库发送的就是在主库上执行的SQL原句，主库会将执行的SQL原有发送到从库中。</p></li>
<li><p><strong>Row：基于行格式</strong></p>
<p>Row模式下，主库会将每次DML操作引发的数据具体行变化记录在Binlog中并复制到从库上，从库根据行的变更记录来对应地修改数据，但DDL类型的操作依然是以Statement的格式记录。</p></li>
<li><p><strong>Mixed：基于混合语句和行格式</strong></p>
<p>MySQL 会根据执行的每一条具体的 SQL 语句来区分对待记录的日志形式，也就是在 statement 和 row 之间选择一种。</p></li>
</ol>
<p>目前互联网业务的在线MySQL集群<strong>全部都是基于Row行格式的Binlog</strong>。虽然这种模式下对资源的开销会偏大，但数据变化的准确性以及可靠性是要强于Statement格式的，同时这种模式下的Binlog提供了完整的数据变更信息，可以使其应用不被局限在MySQL集群系统内。（泛用性强）</p>
<h4 id="主从复制的流程">5.4.3 主从复制的流程</h4>
<figure>
<img onerror="imgOnError(this);" data-fancybox="gallery" src=".\571105f204584cef1c7d31be12a0b610.png" alt="" data-caption="" loading="lazy"><figcaption>在这里插入图片描述</figcaption>
</figure>
<ol type="1">
<li>首先从库启动<strong>I/O</strong>线程，跟主库建立客户端连接。</li>
<li>主库启动<strong>binlog dump</strong>线程，读取主库上的binlog event发送给从库的I/O线程，I/O线程获取到binlog event之后将其写入到自己的Relay Log中。</li>
<li>从库启动<strong>SQL</strong>线程，将等待Relay中的数据进行重放，完成从库的数据更新。</li>
</ol>
<p><strong>为什么存在Relay Log而不是直接commit？</strong></p>
<p>在MySQL 4.0 之前是没有Relay Log这部分的，整个过程中只有两个线程。但是这样也带来一个问题，那就是复制的过程需要同步的进行，很容易被影响，而且效率不高。例如主库必须要等待从库读取完了才能发送下一个binlog事件。这就有点类似于一个阻塞的信道和非阻塞的信道。</p>
<p><strong>主从复制的好处？</strong></p>
<ol type="1">
<li><p><strong>实现复杂均衡</strong></p></li>
<li><p><strong>实现异地备份</strong></p>
<ol start="3" type="1">
<li><strong>提高数据库可用性</strong>（？不就是均衡负载）</li>
</ol></li>
</ol>
<p>主库宕机后，数据可能丢失，从库只有一个sql Thread，主库写压力大，复制可能延迟。</p>
<p>解决方法：</p>
<p>半同步复制 解决数据丢失问题</p>
<p>并行复制 解决从库复制延迟的问题（多个SQL程序并行执行）</p>
<p><strong>异步复制（Asynchronous replication）</strong> MySQL默认的复制即是异步的，主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理，这样就会有一个问题，主如果crash掉了，此时主上已经提交的事务可能并没有传到从上，如果此时，强行将从提升为主，可能导致新主上的数据不完整。</p>
<p><strong>全同步复制（Fully synchronous replication）</strong> 指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的性能必然会收到严重的影响。</p>
<p><strong>半同步复制（Semisynchronous replication）</strong> 介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到relay log中才返回给客户端。相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，这个延迟最少是一个TCP/IP往返的时间。所以，<strong>半同步复制最好在低延时的网络中使用。</strong></p>
<h4 id="数据库读写分离">5.4.4 数据库读写分离</h4>
<p>读写分离常用代理放式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。主服务器处 理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p>
<p><strong>为什么进行读写分离？</strong></p>
<ol type="1">
<li><p>各自读写，极大程度缓解锁争用。</p></li>
<li><p>从服务器可以使用MyISAM引擎，提高查询效率。</p></li>
<li><p>增加冗余，增强可用性。</p></li>
</ol>
<h4 id="主从同步延迟">5.4.5 主从同步延迟</h4>
<p><strong>原因</strong>： 假如⼀个服务器开放 Ｎ 个连接给客户端，这样有会有大量并发的更新操作, 但是从服务器的里面读取 binlog 的线程仅有⼀个， 当某个 SQL 在从服务器上执行的时间稍长或者由于某个 SQL要 进行锁表就会导致主服务器的 SQL 大量积压，未被同步到从服务器里。这就导致了主从不⼀致， 也就是主从延迟。 <strong>解决方法</strong>：</p>
<ol type="1">
<li><p>在对数据安全要求不是很高的情况下关闭从服务器的sync_binlog。</p></li>
<li><p>增加服务器。（？神经）</p></li>
</ol>
<h3 id="mysql执行分析">5.5 MySQL执行分析</h3>
<h4 id="mysql基本执行框架">5.5.1 MySql基本执行框架</h4>
<p>先简单介绍一下下图涉及的一些组件的基本作用帮助大家理解这幅图，在 1.2 节中会详细介绍到这些组件的作用。</p>
<p><strong>连接器</strong>： 身份认证和权限相关(登录 MySQL 的时候)。 <strong>查询缓存</strong>: 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。 <strong>分析器:</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。 <strong>优化器</strong>： 按照 MySQL 认为最优的方案去执行。 <strong>执行器</strong>: 执行语句，然后从存储引擎返回数据。</p>
<figure>
<img onerror="imgOnError(this);" data-fancybox="gallery" src=".\6ef53c54c17058df6007248615b8bb8c.png" alt="" data-caption="" loading="lazy"><figcaption>在这里插入图片描述</figcaption>
</figure>
<h4 id="server层">5.5.2 Server层</h4>
<p><strong>连接器</strong></p>
<p>连接器主要和身份认证和权限相关的功能相关，主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即时管理员修改了该用户的权限，该用户也是不受影响的。 <strong>查询缓存</strong>（MySql 8.0后移除）</p>
<p>查询缓存主要用来缓存我所执行的 SELECT 语句以及该语句的结果集。</p>
<p>连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 sql 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。 移除原因：不常用，表更新后缓存会清空。</p>
<p><strong>分析器</strong>（相当于编译前端）</p>
<p>对sql语句进行解释，分为两个步骤：</p>
<ol type="1">
<li><p>词法分析，提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</p></li>
<li><p>语法分析，讲词法分析得出的词串串联分析语义信息，检查语法是否正确。</p></li>
</ol>
<p><strong>优化器</strong>（相当于编译后端）</p>
<p>优化器的作用就是它认为的最优的执行方案去执行。</p>
<p><strong>执行器</strong></p>
<p>执行器会首先校验用户权限，如果鉴权通过则调用引擎接口。</p>
<h4 id="log系统">5.5.3 Log系统</h4>
<p>进行更新操作时需要同时记录日志，MySql（InnoDB引擎）有两个日志系统Binlog（Server层执行器的）和Redolog（InnoDB引擎的）。</p>
<p>更新流程如下：</p>
<ol type="1">
<li><p>引擎查询到要修改的数据。</p></li>
<li><p>修改目标数据</p></li>
<li><p>引擎记录Redolog，Redolog进入prepare状态，并告诉执行器执行完成。</p></li>
<li><p>执行器收到通知后记录Binlog，随后调用引擎，提交Redolog为提交状态。</p></li>
</ol>
<p><strong>为何要有两个日志系统？</strong></p>
<p>令InnoDB具有crash-safe能力。这里分析两种情况：</p>
<ol type="1">
<li><p>先写Redolog直接提交，然后写Binlog，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 bingog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</p></li>
<li><p>先写 Binlog，然后写 Redolog，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</p></li>
</ol>
<h2 id="数据库设计规范">6. 数据库设计规范</h2>
<h3 id="数据库命名规范">6.1 数据库命名规范</h3>
<ol type="1">
<li><p>所有数据库对象名称必须使用小写字母并用下划线分割</p></li>
<li><p>所有数据库对象名称禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）</p></li>
<li><p>数据库对象的命名要能做到见名识意，并且最好不要超过 32 个字符</p></li>
<li><p>临时库表必须以 tmp_为前缀并以日期为后缀，备份表必须以 bak_为前缀并以日期 (时间戳) 为后缀</p></li>
<li><p>所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）</p></li>
</ol>
<h3 id="数据库设计规范-1">6.2 数据库设计规范</h3>
<ol type="1">
<li><p>使用InnoDB存储引擎</p></li>
<li><p>数据库和表的字符集统一使用 UTF8</p></li>
<li><p>所有表和字段加注释</p></li>
<li><p>尽量控制单表数据量大小，控制在500万以内。</p>
<p>可以使用历史数据归档、分库分表等手段控制数据量</p></li>
<li><p>谨慎使用分区表</p></li>
<li><p>分离冷热数据，减小表宽度</p></li>
<li><p>不要预留字段</p></li>
<li><p>不能存储图片、文件等大二进制数据</p></li>
<li><p>禁止在线上做压力测试</p></li>
<li><p>禁止从开发环境、测试环境链接生成环境数据库</p></li>
</ol>
<h2 id="clickhouse">7. ClickHouse</h2>
<h3 id="概念-2">7.1 概念</h3>
<p>ClickHouse是高性能、MPP架构、列式存储、完备DBMS功能的OLAP数据库</p>
<p><strong>特点</strong></p>
<ol type="1">
<li><p>高性能</p></li>
<li><p>分布式框架</p></li>
<li><p>支持SQL</p></li>
<li><p>支持多种数据类型</p></li>
<li><p>支持多种压缩算法</p></li>
<li><p>免费开源</p></li>
</ol>
<p>其中几个名词的解释：</p>
<h5 id="mpp架构">MPP架构</h5>
<p><a target="_blank" rel="noopener" href="https://m.baidu.com/s?word=MPP%E6%9E%B6%E6%9E%84&amp;sa=re_dqa_zy">MPP架构<em></em></a>（Massively Parallel Processing）是一种设计用于处理大规模数据集的计算架构，其核心思想是将数据处理任务分布在多个处理器上以实现并行计算，从而获得高性能和可扩展性。这种架构的主要优势包括</p>
<ul>
<li>高性能。通过在多个处理器上同时执行任务，MPP架构能够实现高吞吐量和低延迟，显著加速计算过程。</li>
<li>可扩展性。通过增加更多处理器，MPP架构可以扩展系统的计算能力，满足不断增长的数据处理需求。</li>
<li>容错能力。MPP架构通过在多个处理器上冗余数据和计算任务，提高系统的容错性，确保在部分处理器故障时系统的稳定性。</li>
</ul>
<p>MPP架构可以分为不同的类别，包括共享存储和分布式存储两类。共享存储MPP架构中，所有处理器都连接到同一个共享存储系统，使用高速互联网络进行通信，优点是能够实现高速数据访问，但可能存在存储系统性能瓶颈。分布式存储MPP架构中，每个处理器都有其自己的本地存储系统，也通过高速互联网络进行通信，优点是避免了存储系统成为性能瓶颈，但可能需要更复杂的数据分布和通信机制。</p>
<p>MPP架构广泛应用于多个领域，如大数据处理、机器学习、金融风险管理等，在大数据处理方面，它能够有效地处理大量数据，特别是在需要实时分析和处理的场景下；在机器学习和人工智能方面，它能够加速训练和推理过程；在金融风险管理方面，它帮助金融机构快速处理交易数据以实现高效风险管理。</p>
<p>缺点：存储不透明、单节点瓶颈</p>
<p>在设计上，MPP架构优先考虑<strong>一致性</strong>（Consistency），其次考虑<strong>可用性</strong>（Availability），同时尽量做到<strong>分区容错性</strong>（Partition Tolerance）。即保证<strong>CA</strong>属性。MPP架构常用于数据仓库、数据集市、大数据分析等场景，其分布式设计能够有效应对数据规模的不断增长和复杂度的提高，但也会面临一些挑战。</p>
<h5 id="分布式架构">分布式架构</h5>
<p><strong>分布式架构</strong>是一种将计算任务并发分散到多个计算节点上的计算架构，主要用于处理大规模数据和复杂计算问题。这种架构也常称为大数据架构或分布式批处理架构，并且包含多个具体实现，如Hadoop、Spark等。在设计上，分布式系统通常会优先考虑<strong>分区容错性</strong>（Partition Tolerance），其次考虑<strong>可用性</strong>（Availability），尽量做到<strong>一致性</strong>（Consistency）。即保证<strong>AP</strong>属性</p>
<h5 id="dbms">DBMS</h5>
<p>即Database Management System。 数据库管理系统(Database Management System)是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库。</p>
<p><strong>OLAP &amp; OLTP</strong></p>
<p>OLAP（联机分析处理）和OLTP（联机事物处理）</p>
<p>OLTP旨在高效地处理日常的事务，如银行交易、订单处理等，它强调的是事务的处理速度和实时性，主要用于事务数据的录入和实时处理（<strong>注重实时处理</strong>）</p>
<p>OLAP则用于处理大规模数据，支持复杂的数据分析和决策支持，强调从历史数据中提取洞察力，主要用于查询、报表生成和数据分析（<strong>注重历史分析</strong>）</p>
<figure>
<img onerror="imgOnError(this);" data-fancybox="gallery" src=".\7789bf7690ebdcb02e47ac896ed4f566.png" alt="" data-caption="" loading="lazy"><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>其中，OLAP还可分为ROLAP（关系型OLAP）和MOLAP。MOLAP是指带预先结果统计和存储的OLAP，是一种以空间换时间的做法。此外还有HOLAP（细节数据存储在ROLAP，聚合数据存储在MOLAP）。</p>
<p><strong>列式存储</strong></p>
<p>在传统的行式存储中，数据按照行的方式存储，即将每个记录的各个字段按顺序存储在一起，每行数据占用的存储空间相对较大。而列式存储是将每列的数据存储在一起，<strong>优：可以单独进行压缩与解码，占用的存储空间更少，查询效率更高。</strong></p>
<h3 id="clickhouse的优缺点">7.2 ClickHouse的优缺点</h3>
<p>优：查询速度快，可以在存储数据超过20万亿行的情况下，做到了90%的查询能够在1秒内返回。支持高级数据类型，支持自定义函数和聚合函数，支持多种存储引擎。</p>
<p>缺点：针对OLTP业务场景的支持有限：</p>
<ol type="1">
<li><p>不支持事物</p></li>
<li><p>不擅长根据主键按行粒度进行查询（但支持）</p></li>
<li><p>不擅长按行删除数据（但支持）（？内部数据结构和线段树差不多）</p></li>
</ol>
<h3 id="clickhouse高效查询的原因">7.3 ClickHouse高效查询的原因</h3>
<p><strong>列式存储与数据压缩</strong></p>
<p>减少数据扫描范围和数据传输时的大小，列式存储和数据压缩就可以做到这两点。</p>
<p><strong>向量化执行</strong></p>
<p>消除程序中循环的优化，是基于底层硬件实现的优化。</p>
<p><strong>多样化引擎</strong></p>
<p>与MySQL类似，ClickHouse也将存储部分进行了抽象，把存储引擎作为一层独立的接口。目前ClickHouse共拥有合并树、内存、文件、接口和其他6大类20多种表引擎。每一种表引擎都有着各自的特点，用户可以根据实际业务场景的要求，选择合适的表引擎使用。</p>
<p><strong>多线程与分布式</strong></p>
<p>多线程处理就是通过线程级并行的方式实现了性能的提升，ClickHouse将数据划分为多个partition，每个partition再进一步划分为多个index granularity，然后通过多个CPU核心分别处理其中的一部分来实现并行数据处理。这种设计下，可以使得ClickHouse单条Query就能利用整机所有CPU，极致的并行处理能力，极大的降低了查询延时。</p>
<h3 id="clickhouse执行过程">7.4 ClickHouse执行过程</h3>
<figure>
<img onerror="imgOnError(this);" data-fancybox="gallery" src=".\ce4cce91d190077c2a980174a08069eb.png" alt="" data-caption="" loading="lazy"><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>简单来说，就是一条sql,会经由Parser与Interpreter，解析和执行，通过调用Column、DataType、Block、Functions、Storage等模块，最终返回数据，下面是各个模块具体的介绍。</p>
<p><strong>Columns</strong></p>
<p>表示内存中的列（实际上是列块），需使用 IColumn 接口。该接口提供了用于实现各种关系操作符的辅助方法。几乎所有的操作都是不可变的：这些操作不会更改原始列，但是会创建一个新的修改后的列。</p>
<p><strong>Field</strong></p>
<p>表示单个值，有时候也可能需要处理单个值，可以使用Field。Field 是 UInt64、Int64、Float64、String 和 Array 组成的联合。与Column对象的泛化设计思路不同，Field对象使用了聚合的设计模式。在Field对象内部聚合了Null、UInt64、String和Array等13种数据类型及相应的处理逻辑。</p>
<p><strong>DataType</strong></p>
<p>IDataType 负责序列化和反序列化：读写二进制或文本形式的列或单个值构成的块。IDataType直接与表的数据类型相对应。比如，有 DataTypeUInt32、DataTypeDateTime、DataTypeString等数据类型。</p>
<p><strong>Storage</strong></p>
<p>IStorage接口表示一张表。该接口的不同实现对应不同的表引擎。比如StorageMergeTree、StorageMemory等。这些类的实例就是表。</p>
<p><strong>Parser与Interpreter</strong></p>
<p>Parser和Interpreter是非常重要的两组接口：Parser分析器负责创建AST对象；而Interpreter解释器则负责解释AST，并进一步创建查询的执行管道。它们与IStorage一起，串联起了整个数据查询的过程。Parser分析器可以将一条SQL语句以递归下降的方法解析成AST语法树的形式。不同的SQL语句，会经由不同的Parser实现类解析。例如，有负责解析DDL查询语句的ParserRenameQuery、ParserDropQuery和ParserAlterQuery解析器，也有负责解析INSERT语句的ParserInsertQuery解析器，还有负责SELECT语句的ParserSelectQuery等。</p>
<h3 id="clickhouse表引擎">7.5 ClickHouse表引擎</h3>
<h4 id="合并树引擎">7.5.1 合并树引擎</h4>
<p>Clickhouse中最强大的表引擎当属MergeTree（合并树）引擎及该系列（MergeTree）中的其他引擎。</p>
<p>MergeTree系列的引擎被设计用于插入极大量的数据到一张表当中。数据可以以数据片段的形式一个接着一个的快速写入，数据片段在后台按照一定的规则进行合并。相比在插入时不断修改（重写）已存储的数据，这种策略会高效很多。</p>
<p><strong>特点</strong></p>
<ul>
<li>存储的数据按主键排序。这使得您能够创建一个小型的稀疏索引来加快数据检索。</li>
<li>如果指定了分区键的话，可以使用分区。在相同数据集和相同结果集的情况下ClickHouse中某些带分区的操作会比普通操作更快。查询中指定了分区键时ClickHouse会自动截取分区数据。这也有效增加了查询性能。</li>
<li>支持数据副本。ReplicatedMergeTree系列的表提供了数据副本功能。</li>
<li>支持数据采样。需要的话，您可以给表设置一个采样方法。</li>
</ul>
<table>
<thead>
<tr class="header">
<th>引擎名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>MergeTree</td>
<td>适用于查询性能要求较高的数据表，如：时间序列数据。它有一个优化排序和合并的技术，从而提高数据查询速度。</td>
</tr>
<tr class="even">
<td>CollapsingMergeTree</td>
<td>与 MergeTree 相似，但是在累加数据值方面更有优势。它可以在查询中合并多个数据值。</td>
</tr>
<tr class="odd">
<td>SummingMergeTree</td>
<td>与 CollapsingMergeTree 相似，但它专门用于对数值累加。</td>
</tr>
<tr class="even">
<td>ReplacingMergeTree</td>
<td>适用于在数据表中替换某些数据值。如果数据表中存在与新数据重复的键，则它将替换该数据。</td>
</tr>
<tr class="odd">
<td>GraphiteMergeTree</td>
<td>适用于操作时间序列数据，如：Graphite 应用。它对时间序列数据查询具有较高的性能。</td>
</tr>
<tr class="even">
<td>VersionedCollapsingMergeTree</td>
<td>适用于数据版本控制，并且可以在多个版本之间查询数据。</td>
</tr>
<tr class="odd">
<td>Memory</td>
<td>将数据存储在 RAM 中，因此数据查询速度比磁盘存储快得多。不过，由于它是在内存中存储数据，因此它通常不适用于大数据量的数据表。</td>
</tr>
<tr class="even">
<td>Buffer</td>
<td>缓存引擎，用于存储缓存表。适用于中间结果，可以在内存和磁盘之间快速切换 相对于内存引擎的读写速度较慢，数据不能永久保存。</td>
</tr>
</tbody>
</table>
<h4 id="日志引擎">7.5.2 日志引擎</h4>
<p>用于日志存储的存储引擎，这些引擎是为了需要写入许多小数据量（少于一百万行）的表的场景而开发的。</p>
<p>这系列的引擎有：</p>
<ul>
<li>StripeLog</li>
<li>Log</li>
<li>TinyLog</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li><p>数据存储在磁盘上。</p></li>
<li><p>写入时将数据追加在文件末尾。</p></li>
<li><p>不支持突变操作,也就是更新。</p></li>
<li><p>不支持索引。 这意味着 <code>SELECT</code> 在范围查询时效率不高。</p></li>
<li><p>非原子地写入数据。 如果某些事情破坏了写操作，例如服务器的异常关闭，你将会得到一张包含了损坏数据的表。</p></li>
</ul>
<h3 id="高级数据结构">7.6 高级数据结构</h3>
<p>ClickHouse支持多种数据类型，包括<strong>基本数据类型</strong>、<strong>复合数据类型</strong>和<strong>几何数据类型</strong>。</p>
<figure>
<img onerror="imgOnError(this);" data-fancybox="gallery" src=".\c1705452d563d02b70d92875793bc270.png" alt="" data-caption="" loading="lazy"><figcaption>在这里插入图片描述</figcaption>
</figure>
<h3 id="cilckhouse-vs-传统关系型数据库">7.7 CilckHouse vs 传统关系型数据库</h3>
<ol type="1">
<li><p>ClickHouse的数据模型是基于表的，与创建表时指定的数据存储类型和存储引擎有关，支持多种高级数据类型。</p></li>
<li><p>ClickHouse的数据模型是列式存储的（传统关系型数据库为行式存储），每个列可以单独进行压缩与解码，存储空间更少，查询效率高。</p></li>
<li><p>ClickHouse是OLAP数据库，用于处理大规模数据，支持复杂的数据分析和决策支持，强调从历史数据中提取洞察力，主要用于查询、报表生成和数据分析（<strong>注重历史分析，查统增改快，删慢</strong>）</p></li>
<li><p>OLTP能力有限，不支持事物。</p></li>
</ol>
<h3 id="ddl-dml">7.8 DDL &amp; DML</h3>
<p>ClickHouse的DDL和DML是ClickHouse SQL，它与传统的SQL具有很高的兼容性，但也有一些专门为ClickHouse设计的特殊语法和函数，以便更好地支持列式存储和分布式计算。</p>
<p><strong>特点</strong></p>
<ol type="1">
<li><p>支持多种查询</p></li>
<li><p>优化查询性能</p></li>
<li><p>支持高级数据结构</p></li>
<li><p>支持自定义函数和聚合函数</p></li>
<li><p>支持多种存储引擎</p></li>
</ol>
<p><strong>一个建表的例子</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> encoded_data (<br>    eventdate <span class="hljs-type">Date</span> CODEC(Delta, LZ4),<br>    event_type String CODEC(ZSTD),<br>    <span class="hljs-keyword">value</span> UInt32<br>) ENGINE <span class="hljs-operator">=</span> MergeTree()<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> event_date<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span>(event_type);<br></code></pre></td></tr></table></figure>
<p>大部分与SQL标准一致，其中<code>CODEC</code>指定改列的数据压缩和数据编码方法。<code>ENGINE=MergeTree()</code>用于指定数据存储引擎。</p>
<p><code>ORDER BY event_date</code>是指将会按照<code>event_date</code>这一字段排序。</p>
<p><code>PARTITION BY(event_type)</code> 是指数据会通过<code>event_type</code>这一字段进行分区。</p>
<h3 id="数据压缩与编码">7.9 数据压缩与编码</h3>
<h4 id="数据压缩">7.9.1 数据压缩</h4>
<p>数据压缩是通过消除数据中的冗余信息来减少数据大小的过程。在ClickHouse中，数据压缩主要通过两种压缩算法实现：LZ4和ZSTD。</p>
<p><strong>LZ4（默认压缩算法）</strong></p>
<p>LZ4是一种无损压缩算法，它提供了较高的压缩速度和较低的解压缩速度。LZ4适用于大多数场景，因为它可以在不影响查询性能的情况下显著减少存储空间。</p>
<p><strong>ZSTD</strong></p>
<p>ZSTD（Zstandard）是一种无损压缩算法，它提供了较高的压缩比和较低的解压缩速度。相比LZ4，ZSTD可以进一步减少存储空间，但解压缩速度较慢。ZSTD适用于对存储空间有严格要求的场景。</p>
<p>压缩率：LZ4 &lt; ZSTD</p>
<p>解压速度：LZ4 &gt; ZSTD</p>
<h4 id="数据编码">7.9.2 数据编码</h4>
<p>数据编码是通过对数据进行转换来减少数据大小的过程。在ClickHouse中，数据编码主要通过两种技术实现：Delta和Gorilla。</p>
<p><strong>Delta</strong></p>
<p>Delta编码是一种差分编码技术，它通过存储相邻数据之间的差值来减少数据大小。Delta编码适用于具有连续值或递增值的数据，如时间序列数据。在ClickHouse中，Delta编码可以与LZ4或ZSTD压缩算法结合使用，以进一步减少存储空间。</p>
<p><strong>Gorilla</strong></p>
<p>Gorilla编码是一种专为时间序列数据设计的编码技术，它通过存储相邻数据之间的XOR值来减少数据大小。与Delta编码相比，Gorilla编码可以实现更高的压缩比，但仅适用于时间序列数据。在ClickHouse中，Gorilla编码可以与LZ4或ZSTD压缩算法结合使用，以进一步减少存储空间。</p>
<h3 id="分布式结构">7.10 分布式结构</h3>
<h4 id="角色">7.10.1 角色</h4>
<p>ClickHose是一个分布式系统，内含多种角色的服务器。</p>
<figure>
<img onerror="imgOnError(this);" data-fancybox="gallery" src=".\797f657dc266385296123fe4a9d81093.png" alt="" data-caption="" loading="lazy"><figcaption>在这里插入图片描述</figcaption>
</figure>
<h4 id="本地表和分布式表">7.10.2 本地表和分布式表</h4>
<p><strong>本地表</strong></p>
<p>当使用一般的<code>CREATE</code>语句进行建表时，所建立的表只会存在在一台ClickHouse Server上，这种表称为<strong>本地表</strong></p>
<p><strong>分布式表</strong></p>
<p>一个逻辑上的表, 可以理解为数据库中的视图, 一般查询都查询分布式表. 分布式表引擎会将我们的查询请求路由本地表进行查询, 然后进行汇总最终返回给用户。</p>
<p><strong>为什么不在分布式表进行写入？</strong></p>
<ol type="1">
<li><p>分布式表接收到数据后会将数据拆分成多个parts，并转发数据到其他服务器，会引起服务器间网络流量增加、服务器merge的工作量增加，导致写入速度变慢，并且增加了Too many parts的可能性</p></li>
<li><p>数据的一致性问题，现在分布式表所在的机器进行落盘，然后异步的发送到本地表所在的机器上进行存储，中间没有一致性的校验，而且在分布式表所在机器如果集群出现down机，会存在数据丢失风险。</p></li>
<li><p>对zookeeper的压力比较大。</p></li>
</ol>
<p>在实际生成环境中通常只读分布式表，写入本地表。</p>
<h4 id="数据同步与查询数据切片和冗余">7.10.3 数据同步与查询（数据切片和冗余）</h4>
<p><strong>Replication &amp; Sharding</strong></p>
<p>ClickHouse依靠ReplicatedMergeTree引擎族与ZooKeeper实现了复制表机制, 成为其高可用的基础。ClickHouse像ElasticSearch一样具有数据分片(shard)的概念, 这也是分布式存储的特点之一, 即通过并行读写提高效率。 ClickHouse依靠Distributed引擎实现了分布式表机制, 在所有分片（本地表）上建立视图进行分布式查询。</p>
<figure>
<img onerror="imgOnError(this);" data-fancybox="gallery" src=".\215cf87405f60dd8e3e911d8778b6361.png" alt="" data-caption="" loading="lazy"><figcaption>在这里插入图片描述</figcaption>
</figure>
<p><strong>Shard（切片）</strong>：表内数据的一段</p>
<p><strong>Replicated（冗余）</strong>：表内数据的一段副本。</p>
<p><strong>Replicated Table &amp; ReplicatedMergeTree Engine</strong></p>
<p>ReplicatedMergeTree是支持实现高可用的Replicated Table（复制表）的引擎，ReplicatedMergeTree引擎族非常依赖于zookeeper, 它在zookeeper中存储了大量的数据。</p>
<p><strong>Distributed Table &amp; Distributed Engine</strong></p>
<p>ClickHouse分布式表的本质并不是一张表,，而是一些本地物理表(分片)的分布式视图，本身并不存储数据.。分布式表建表的引擎为Distributed。</p>
<p><strong>数据同步流程</strong></p>
<figure>
<img onerror="imgOnError(this);" data-fancybox="gallery" src=".\0d44200ec02878be4935d11c983553f8.png" alt="" data-caption="" loading="lazy"><figcaption>在这里插入图片描述</figcaption>
</figure>
<ol type="1">
<li><p>写入到一个节点</p></li>
<li><p>通过interserver HTTP port端口同步到其他实例上</p></li>
<li><p>更新zookeeper集群记录的信息</p></li>
</ol>
<p><strong>数据查询流程</strong></p>
<figure>
<img onerror="imgOnError(this);" data-fancybox="gallery" src=".\fc48b37fb567ad6db8a8d77d64585fa7.png" alt="" data-caption="" loading="lazy"><figcaption>在这里插入图片描述</figcaption>
</figure>
<ol type="1">
<li><p>各个实例之间会交换自己持有的分片的表数据</p></li>
<li><p>汇总到同一个实例上返回给用户</p></li>
</ol>
<p><strong>写入去重</strong></p>
<p>可复制表写入去重：注意，只有对于复制表系列才有写入去重机制，并不是所有的表都有写入去重机制的。可复制表的写入去重依赖于zookeeper。</p>
<p>clickhouse在zookeeper上的默认路径为 /clickhouse。对于可复制表的写入，每次写入，将所有写入的数据按照规则划分为一个个block，对每一个block计算一个校验和，将校验和存储在zookeeper的 /clickhouse/tables/分片号/数据库名/表名/blocks路径下（这个路径和 可复制表的参数也有关）的一个节点上。每次写入的时候，比较数据块的校验和已有的数据块校验和关系，用以判断写入数据是否重复。 <strong>ClickHouse支持哪些分布式部署方案，如何进行分布式查询？</strong></p>
<p>ClickHouse支持以下几种分布式部署方案：</p>
<ol type="1">
<li><p>分片复制部署：将数据划分为多个分片，每个分片都有多个副本，每个副本都可以读写数据。在这种部署方案中，每个节点都可以执行查询，但只有主副本可以执行写操作。当主副本出现故障时，会自动切换到备副本。</p></li>
<li><p>分片无复制部署：将数据划分为多个分片，每个分片只有一个副本。在这种部署方案中，每个节点都可以执行查询和写操作。</p></li>
<li><p>复制无分片部署：所有数据都复制到每个节点上，每个节点都可以执行查询和写操作。这种部署方案适合小型集群和低并发查询。</p></li>
</ol>
<p>分布式查询可以通过以下两种方式进行：</p>
<ol type="1">
<li><p>基于分布式查询引擎：ClickHouse提供了分布式查询引擎，允许用户在多个节点上并行执行查询，并将结果汇总到一个节点上。分布式查询引擎可以处理大量数据，并且可以根据查询的特点自动调整查询计划，提高查询性能。</p></li>
<li><p>基于分布式存储引擎：ClickHouse支持分布式存储引擎，可以将数据分布到多个节点上，实现数据的并行读取和写入。在这种情况下，查询可以在多个节点上执行，并通过网络传输数据进行计算。这种方法适用于需要在多个节点上分析大量数据的场景。</p></li>
</ol>
<h3 id="数据组织与索引">7.11 数据组织与索引</h3>
<h4 id="分区partition">7.11.1 分区（Partition）</h4>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> encoded_data (<br>    eventdate <span class="hljs-type">Date</span> CODEC(Delta, LZ4),<br>    event_type String CODEC(ZSTD),<br>    <span class="hljs-keyword">value</span> UInt32<br>) ENGINE <span class="hljs-operator">=</span> MergeTree()<br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> event_date<br><span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span>(event_type);<br></code></pre></td></tr></table></figure>
<p><code>PARTITION BY(event_type)</code> 是指数据会通过<code>event_type</code>这一字段进行分区。在ClickHouse进行数据组织存储时，会按照某个字段分组存储，这被称为分区。在上述例子中，<code>encoded_data</code>中的所有数据将会按照<code>event_type</code>分成数个组，分别进行存储。</p>
<figure>
<img onerror="imgOnError(this);" data-fancybox="gallery" src=".\5bf2818bd4a206f20ff3fbcfc68c7f7c.png" alt="" data-caption="" loading="lazy"><figcaption>在这里插入图片描述</figcaption>
</figure>
<p><strong>为什么要分区？（分区优点）</strong></p>
<p>提高查询速度，减少不必要额数据读取。where子句中查询某一类别只需要到该类别对应的分区查询即可。</p>
<h4 id="列式存储">7.11.2 列式存储</h4>
<p>在传统的行式存储中，数据按照行的方式存储，即将每个记录的各个字段按顺序存储在一起，每行数据占用的存储空间相对较大。而列式存储是将每列的数据存储在一起。</p>
<p><strong>为什么要用列式存储？（行式存储 vs 列式存储）</strong></p>
<p>在进行OLAP业务有优势，在进行统计和查询时只取其中的几个列。而行式存储需要读取每一行的整个条目，然后在选择列。但是于此同时，对于记录的删除，修改则需要耗费更高的成本，这也是为什么Clickhouse不擅长删除的原因。</p>
<p>此外，列式存储更容易去做数据编码和压缩。</p>
<p><strong>总而言之：列存储适合OLAP业务，行存储适合OLTP业务</strong></p>
<h4 id="mergetree的数据组织和索引">7.11.3 MergeTree的数据组织和索引</h4>
<p><strong>数据组织</strong></p>
<figure>
<img onerror="imgOnError(this);" data-fancybox="gallery" src=".\2fa67201063e40be3f3ca311820e9a30.png" alt="" data-caption="" loading="lazy"><figcaption>在这里插入图片描述</figcaption>
</figure>
<p><strong>稀疏索引</strong></p>
<p>稀疏索引是一套在设定的有序列上建立的索引。它是一个粗粒度索引，被记录在<code>primay.idx</code>。它每隔固定的行数建立一个索引指针指向当前行数。例如在下图中通过有序列age建立索引，其中每隔5列建立一个索引指针。适用稀疏索引可以快速确定所要查询的记录在表中的位置区域。在进行查询时先通过<code>primay.idx</code>获取要查询的区域序号，在通过各列的<code>column.mrk2</code>文件找到该区域的偏移量，随后到各列文件中的对应位置检索数据。</p>
<figure>
<img onerror="imgOnError(this);" data-fancybox="gallery" src=".\23e439acb14eca4d96618ebdcc244375.png" alt="" data-caption="" loading="lazy"><figcaption>在这里插入图片描述</figcaption>
</figure>
<figure>
<img onerror="imgOnError(this);" data-fancybox="gallery" src=".\7eca656f8ad636697b9aaa0e829802ba.png" alt="" data-caption="" loading="lazy"><figcaption>在这里插入图片描述</figcaption>
</figure>
<p><strong>数据插入方法</strong></p>
<p>当有新的一批数据插入分区时，并不会直接插入到原分区的各个列内，（Why？因为那样需要对分区重新排序，重新构建索引。）而是针对这新的一批数据建立一套独立的稀疏索引，然后挂载到MergeTree中。</p>
<figure>
<img onerror="imgOnError(this);" data-fancybox="gallery" src=".\777e8ae6ffa39ddb578fcd5dd24a2c00.png" alt="" data-caption="" loading="lazy"><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>此时要进行快速查询需要在每个part内部分别进行查询，然后将结果合并。</p>
<p><strong>异步合并</strong></p>
<p>为了不使part过多，ClickHouse会对同一个partition下的part进行异步合并。</p>
<p><strong>ClickHouse的索引类型是什么，如何使用索引来提高查询性能？</strong></p>
<p>ClickHouse支持以下三种索引类型：</p>
<ol type="1">
<li><p>稠密索引(Dense Index)：稠密索引是一种基于跳跃表的索引结构，用于在有序列上进行范围查询。在ClickHouse中，稠密索引使用较少的空间来存储数据，并且可以加快查询速度。</p></li>
<li><p>稀疏索引(Sparse Index)：稀疏索引是一种基于哈希表的索引结构，用于在无序列上进行查询。稀疏索引只在查询时创建，因此可以减少索引的空间占用。</p></li>
<li><p>索引光标(Index Cursor)：索引光标是一种用于加速聚合查询的技术。它允许ClickHouse在数据分片和节点之间进行快速分布式聚合查询。</p></li>
</ol>
<p><strong>ClickHouse的数据写入和数据删除是如何实现的？</strong> 在往 ClickHouse 中写入数据时，它会先将数据写入的内存表中，当内存表达到一定的大小后，将内存表中的数据写入新的数据块中，根据数据的时间戳确定数据块的位置。当数据块达到一定大小后，会进行归并排序，存储到更大的数据块中，形成一个更大的分区，最终进行长期的存储。</p>
<p>ClickHouse 使用 alter table 关键字进行数据删除，它是一种逻辑删除。通过添加一个标记字段来区分数据是否被删除，并不会删除真正的数据，只有在分片时才会真正的清理。 <strong>ClickHouse的内存管理和垃圾回收机制是怎样的？</strong> ClickHouse 采用自己实现的内存池来管理内存，这样可以快速地进行内存分配和回收。ClickHouse 也可以设置内存限制，以确保查询过程中不会耗尽系统内存，一旦达到内存限制，ClickHouse 将会自动开始垃圾回收，以释放一些内存。</p>
<p>ClickHouse 使用的是一种自适应的垃圾回收机制，当内存使用达到限制时会自动进行回收，选择尽可能少的数据进行回收，同时避免产生大量的垃圾数据。 <strong>ClickHouse如何处理时序数据和实时数据？</strong> ClickHouse 支持专门的时序数据库引擎 —— MergeTree 引擎，该引擎是针对时间序列数据设计的，能够快速地处理基于时间的查询和聚合操作。</p>
<p>ClickHouse 提供了 Kafka 引擎，能够直接消费 Kafka 消息队列中的数据，并将其存储到 ClickHouse 中。还支持对实时数据进行预处理和聚合操作，从而实现实时数据分析和监控。</p>
<p><strong>ClickHouse支持哪些数据导入和导出方式？</strong> 支持csv、json、orc、parquet、MySQL等关系型数据库、NoSQL，还支持从消息队列和存储系统中导入和导出数据，例如：Kafka、Redis等。</p>
<h4 id="向量化计算">7.11.4 向量化计算</h4>
<p>向量化计算是一种特殊的并行计算方式。相比于一般程序在同一时间只执行一个操作的方式，它可以一次计算一组数据（向量）。SIMD(Single Instruction Multiple Data): 即单指令流多数据流。</p>
<h3 id="物化视图">7.12 物化视图</h3>
<p>物化视图是包括一个查询结果的数据库对象，利用空间换时间。可以避免多基础表的频繁查询，尤其是固定查询。可以显著提高查询的性能。</p>
<p><strong>一致性保证</strong></p>
<p>物化视图保证了数据一致性，即原表数据发生改变，物化视图内的数据也会跟着改变。能够完成该特性的存储引擎是AggregatingMergeTree。</p>
<h2 id="redis">8. Redis</h2>
<h3 id="redis简介与适用场景">8.1 Redis简介与适用场景</h3>
<p>Redis是一个key-value存储系统，它支持存储的value类型相对更多，包括string、list、set、zset（sorted set --有序集合）和hash。这些数据结构都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，Redis支持各种不同方式的排序。为了保证效率，数据都是缓存在内存中，Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave（主从）同步。 <strong>使用场景</strong></p>
<ol type="1">
<li>Redis是基于内存的nosql数据库，可以通过新建线程的形式进行持久化，不影响Redis单线程的读写操作。</li>
<li>通过list取最新的N条数据。</li>
<li>模拟类似于token这种需要设置过期时间的场景。</li>
<li>发布订阅消息系统。</li>
<li>定时器、计数器。</li>
</ol>
<p><strong>功能</strong></p>
<ol type="1">
<li><p>本机内存缓存</p>
<p>当调用api访问数据库时，假如此过程需要2秒，如果每次请求都要访问数据库，那将对服务器造成巨大的压力，如果将此sql的查询结果存到Redis中，再次请求时，直接从Redis中取得，而不是访问数据库，效率将得到巨大的提升，Redis可以定时去更新数据（比如1分钟）。</p></li>
<li><p>持久化存储</p></li>
<li><p>哨兵和复制</p>
<p>Sentinel可以管理多个Redis服务器，它提供了监控、提醒以及自动的故障转移功能；</p>
<p>复制则是让Redis服务器可以配备备份的服务器；Redis也是通过这两个功能保证Redis的高可用；</p></li>
<li><p>集群</p></li>
</ol>
<p><strong>支持的数据类型</strong></p>
<ol type="1">
<li><p>字符串</p></li>
<li><p>hash</p></li>
<li><p>list</p></li>
<li><p>set</p></li>
<li><p>zset （有序set）</p></li>
</ol>
<h3 id="redis-io多路复用">8.2 Redis IO多路复用</h3>
<h4 id="概念-3">8.2.1 概念</h4>
<p>在Redis中，IO多路复用是一种技术，允许单个线程处理多个网络连接。它利用了select、poll、epoll等机制，能够同时监视多个描述符（fd），一旦某个描述符就绪（读/写/异常），就能通知程序进行相应的读写操作。</p>
<p>这种技术可以避免大量的无用操作，因为在空闲的时候，会将当前线程阻塞掉。当有一个或多个流有I/O事件时，就从阻塞态中唤醒，程序会轮询一遍所有的流（epoll是只轮询那些真正发出了事件的流），依次顺序的处理就绪的流。</p>
<p>IO多路复用可以高效的处理多个连接请求（尽量减少网络IO的时间消耗），让单个线程能同时处理多个客户端的连接。在Redis中，由于内存内的操作不会成为性能瓶颈，所以IO多路复用可以让Redis具有很高的吞吐量。</p>
<h4 id="原理">8.2.2 原理</h4>
<p>IO多路复用（IO Multiplexing）的工作原理是利用一种机制同时监视多个文件描述符，以查看它们是否就绪，然后进行读写操作。这种技术允许多个连接同时被处理，而不需要为每个连接创建一个新的线程或进程。它是一种非阻塞的IO模型，通过在单个线程中处理多个连接来提高效率和减少资源消耗。</p>
<ol type="1">
<li><p>注册：将要监视的文件描述符（sockets）注册到IO多路复用函数中（例如，select、poll或epoll）。</p></li>
<li><p>监视：IO多路复用函数开始监视所有注册的文件描述符。</p></li>
<li><p>检查：IO多路复用函数定期检查每个文件描述符的状态，查看它们是否准备好进行读或写操作。</p></li>
<li><p>处理：当某个文件描述符就绪时，IO多路复用函数会通知应用程序，应用程序可以执行相应的读或写操作。</p></li>
<li><p>轮询：应用程序可以在一个循环中轮询所有文件描述符，检查它们的状态并执行相应的操作。</p></li>
</ol>
<h3 id="redis-vs-memcached">8.3 Redis vs Memcached</h3>
<p>Memcached是高性能的分布式内存缓存服务器。使用目的一般是从缓存中读取数据，减少数据库访问次数，提高动态web应用速度。</p>
<ol type="1">
<li><p>Redis相比memecache，拥有更多的数据结构和支持更丰富的数据操作。</p></li>
<li><p>内存使用率对比，Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于memecache。</p></li>
<li><p>性能对比：Redis只使用单核，memecache使用多核。</p></li>
<li><p>Redis支持磁盘持久化，memecache不支持。</p></li>
<li><p>Redis支持分布式集群，memecache不支持。</p></li>
</ol>
<h3 id="消息队列">8.4 消息队列</h3>
<h4 id="概念-4">8.4.1 概念</h4>
<p>消息队列（Message Queue）的主要能力应该是解耦和削峰。</p>
<ul>
<li>在有了 mq 后，producer 不需要过分关心 consumer 的身份信息，只需要把消息按照指定的协议投递到对应的 topic 即可。</li>
<li>producer 在处理请求时，只需要把消息投递到 mq 即可认为流程处理结束，相比于同步请求下游，整个流程会更加轻便灵活，拥有更高的吞吐量。</li>
<li>因为有 mq 作为缓冲层. 下游 consumer 可以设定好合适的消费限流参数，按照指定的速率进行消费，能够在很大程度上对 consumer 起到保护作用。</li>
</ul>
<p><strong>流程类型</strong></p>
<p>push型：mq主动将消息推送到consumer。</p>
<p>优：实时性强，契合发布/订阅模型</p>
<p>缺：对下游consumer保护力度不够。（削峰不太好）</p>
<p>pull型：consumer主动从mq拉取消息</p>
<p>优：consumer有主动权，选择在合适时机消费。</p>
<p>缺：实时性弱。</p>
<h4 id="redis-channel">8.4.2 Redis Channel</h4>
<p>Redis Channel 是一种消息传递机制，允许发布者向特定频道发布消息，而订阅者则通过订阅频道实时接收消息。</p>
<p>Redis Channel 的消息传输是通过 Redis PUB/SUB 模型实现的。发布者使用 PUBLISH 命令将消息发送到指定的频道，订阅者使用 SUBSCRIBE 命令订阅指定频道。值得注意的是，频道的主要作用是实现实时消息传递，频道信息并不存储在数据库中，而是在内存中动态生成，所以在 Redis 重启后信息将消失，如果要存储频道信息，需要引入另外的方案。</p>
<h4 id="redis-stream">8.4.3 Redis Stream</h4>
<p>Redis Stream 是 Redis 5.0 版本新增加的数据结构。</p>
<p>Redis Stream 主要用于消息队列（MQ，Message Queue），Redis 本身是有一个 Redis 发布订阅 (pub/sub) 来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。简单来说发布订阅 (pub/sub) 可以分发消息，但无法记录历史消息。</p>
<p>而 Redis Stream 提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</p>
<p><strong>Redis Channel vs Redis Stream</strong></p>
<p>两者均可以完成消息队列的实现，而Redis Stream相比Channel，可以进行消息的持久化存储，提供主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</p>
<h3 id="redis机制">8.5 Redis机制</h3>
<h4 id="redis过期删除策略">8.5.1 Redis过期删除策略</h4>
<p>Redis所有的数据结构都可以设置过期时间，时间一到，这些数据就会变成过期数据，这个时候就需要进行删除。在redis中有3种过期数据删除策略：<strong>惰性删除和定期删除及定时删除</strong></p>
<p><strong>定时删除</strong></p>
<p>定时删除对每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即对key进行清除。</p>
<p>优点：立即删除能保证内存中数据的最大新鲜度，因为它保证过期键值会在过期后马上被删除，其所占用的内存也会随之释放。对内存来说是非常友好的。</p>
<p>缺点： 立即删除对cpu是最不友好的。因为删除操作会占用cpu的时间，如果刚好碰上了cpu很忙的时候，比如正在做交集或排序等计算的时候，就会给cpu造成额外的压力。 <strong>定期删除</strong></p>
<p>定期删除策略每隔一段时间执行一次删除过期键操作并通过限制删除操作执行时长和频率来减少删除操作对CPU时间的影响。定时任务的发起的频率由redis.conf配置文件中的hz来进行配置，Redis 默认每 1 秒运行 10 次，也就是每 100 ms 执行一次，每次随机抽取一些设置了过期时间的 key（这边注意不是检查所有设置过期时间的key，而是随机抽取部分），检查是否过期，如果发现过期了就直接删除。建议不要将这个值（hz）设置超过 100，否则会对CPU造成比较大的压力。</p>
<p>定期清理的两种模式：</p>
<ol type="1">
<li><p>SLOW模式是定时任务，执行频率默认为10hz，每次不超过25ms，以通过修改配置文件redis.conf 的 hz 选项来调整这个次数</p></li>
<li><p>FAST模式执行频率不固定，每次事件循环会尝试执行，但两次间隔不低于2ms，每次耗时不超过1ms</p></li>
</ol>
<p>定期删除注意事项：</p>
<ol start="3" type="1">
<li><p>如果删除操作执行次数过多、执行时间太长，就会导致占用大量cpu资源去进行删除操作。</p></li>
<li><p>如果删除操作次数太少、执行时间短，就会导致内存资源被持续占用，得不到释放。</p></li>
</ol>
<p>优点：可以通过限制删除操作执行的时长和频率来减少删除操作对 CPU 的影响。另外定期删除，也能有效释放过期键占用的内存。</p>
<p>缺点：难以确定删除操作执行的时长和频率。</p>
<p><strong>惰性删除</strong></p>
<p>惰性删除不会去主动删除数据，而是在访问数据的时候，再检查当前键值是否过期，如果过期则执行删除并返回 null 给客户端，如果没有过期则返回正常信息给客户端。</p>
<p>优点：对 CPU友好，我们只会在使用该键时才会进行过期检查，对于很多用不到的key不用浪费时间进行过期检查。</p>
<p>缺点：内存泄漏，就是一个键已经过期，如果我们一直不去访问它，然后的话让这个键仍然保留在redis中，也就是意味着这个过期键不被删除，它所占用的内存就不会释放。因此对于内存是很不友好的， 除非我们手动执行FLUSHDB（用于清空当前数据库中的所有 key）。</p>
<table>
<thead>
<tr class="header">
<th>删除策略</th>
<th>特点</th>
<th>对CPU资源的利用</th>
<th>总结</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>定时删除</td>
<td>节约内存，无占用</td>
<td>不分时段占用CPU资源，频度高。</td>
<td>时间换空间</td>
</tr>
<tr class="even">
<td>定期删除</td>
<td>折中，定期清理内存。</td>
<td>延时进行，CPU利用率高。</td>
<td>随机抽查，重点抽查。</td>
</tr>
<tr class="odd">
<td>惰性删除</td>
<td>内存占用严重</td>
<td>每次查询耗费CPU资源。</td>
<td>拿空间换时间</td>
</tr>
</tbody>
</table>
<h4 id="内存淘汰机制">8.5.2 内存淘汰机制</h4>
<p>当内存被占满（到达所配置的最大内存占用空间后），需要进行数据的淘汰。Redis提供8种内存淘汰策略。</p>
<p><strong>noeviction（默认）</strong> 不删除任何数据，拒绝写入操作并返回Out of Memory错误。</p>
<p><strong>alllkeys-lru</strong> 从所有key中使用LRU算法（最近最少使用）</p>
<p><strong>allkeys-lfu</strong> 从所有key中使用LFU算法（最不常用算法 4.0新增）</p>
<p><strong>volatile-lru</strong> 从设置了过期时间中key中使用LRU算法</p>
<p><strong>volatile-lfu</strong> 从设置了过期时间中key中使用LFU算法</p>
<p><strong>allkey-random</strong> 从所有key中随机淘汰</p>
<p><strong>volatile-random</strong> 从设置了过期时间中key中随机淘汰</p>
<p><strong>volatile-ttl</strong> 淘汰距离过期时间最近的</p>
<p><strong>注意：</strong> 当使用 volatile-lru、volatile-lfu、volatile-random、volatile-ttl 这四种淘汰策略时，如果没有 key 可以淘汰，则和 neoviction 一样返回错误。</p>
<p><strong>何时应该选择何种淘汰策略？</strong></p>
<p>根据应用程序的访问模式，选择正确的淘汰策略很重要，但是你可以在程序运行时重新配置策略，并使用 Redis 的 info 命令 输出来监控缓存未命中和命中的数量，以调整设置。</p>
<p>经验上来讲：</p>
<p>使用 allkeys-lru 策略场景：</p>
<ol type="1">
<li><p>当你期望元素的子集将比其他元素更频繁地被访问时，比如幂律分布，20%的数据占有80%的使用次数；</p></li>
<li><p>当你不确定使用哪种策略时。</p></li>
</ol>
<p>使用 allkeys-random 策略场景：</p>
<ol type="1">
<li><p>当你有一个循环访问，其中所有 key 进行会被连续地访问；</p></li>
<li><p>当你希望所有 key 的分布比较均匀。</p></li>
</ol>
<p>使用 volatile-ttl 策略场景：</p>
<ol type="1">
<li>当你大部分缓存都设有不同的 ttl 值，向 Redis 提供过期候选的提示时。</li>
</ol>
<h4 id="redis持久化机制">8.5.3 Redis持久化机制</h4>
<p>Redis 的持久化指的是将内存中的数据持久化，Redis 服务器重启或宕机时能够恢复数据。Redis 支持两种持久化方式：RDB 和 AOF。</p>
<p><strong>RDB持久化</strong></p>
<p>RDB 持久化方式会将内存中的数据以快照的形式写入到磁盘上，保证了 Redis 服务器重启后数据不丢失。在执行 RDB 持久化时，Redis 会触发保存操作，并创建一个子进程来进行数据快照的写入操作。当快照写入完成后，Redis 会将生成 RDB 文件的时间戳、版本信息等元数据信息保存到服务器状态中，表示 RDB 持久化操作已经完成。</p>
<p>RDB 持久化方式分为两个部分：Snapshot 和 Save。其中 Snapshot 是指 Redis 的内存数据集，而 Save 则是将 Snapshot 持久化到硬盘上（即将内存数据快照写到 RDB 文件中）。以下是 RDB 持久化的流程：</p>
<ol type="1">
<li><p>触发保存操作；</p>
<p>Redis 提供了多种触发保存操作的方式，如调用 SAVE 或 BGSAVE 命令、设置 SAVE 配置选项等。当触发保存操作时，Redis 会开始执行 RDB 持久化操作。</p></li>
<li><p>创建子进程；</p>
<p>由于 Redis 是单线程的，所以在执行持久化操作时需要fork一个子进程来进行操作，防止主进程被阻塞。</p></li>
<li><p>将数据写入临时文件</p>
<p>子进程会遍历整个内存数据集快照，并将快照写入到一个临时文件中，这个过程中内存数据集可以继续处理命令请求。</p></li>
<li><p>移动临时文件到目标文件</p>
<p>当子进程完成快照写入操作后，会将临时文件移动到目标文件，这个过程中 Redis 会使用原子操作来保证数据的完整性和一致性。</p></li>
<li><p>完成持久化操作</p>
<p>当目标文件生成之后，Redis 会将生成 RDB 文件的时间戳、版本信息等元数据信息保存到服务器状态中，表示 RDB 持久化操作已经完成。</p></li>
</ol>
<p><strong>SAVE &amp; BGSAVE</strong></p>
<p>Redis 的 SAVE 和 BGSAVE 命令都是用来进行 RDB 持久化的命令，它们的作用和用法不太一样。</p>
<p>1）SAVE 命令</p>
<p>SAVE 命令会在当前 Redis 进程执行期间阻塞所有客户端请求，直到 RDB 持久化完成为止。这个命令适合用于小规模数据集的保存操作，因为它会占用 Redis 主进程，可能会造成服务暂停的情况。</p>
<p>2）BGSAVE 命令</p>
<p>BGSAVE 命令会创建一个子进程，用于执行 RDB 持久化操作，然后主进程可以继续响应客户端请求。这个命令适合用于大规模数据集的保存操作，因为它不会阻塞 Redis 主进程，不会影响服务的正常运行。</p>
<p>需要注意的是，在执行 BGSAVE 命令时，由于子进程需要遍历整个内存数据集进行快照写入操作，可能会占用大量 CPU 和内存资源，导致 Redis 服务器的性能下降。因此，建议在系统空闲时执行 BGSAVE 命令，并设置适当的 RDB 文件大小和保存规则，以保证数据的安全性和服务的稳定性。</p>
<p>另外，如果 BGSAVE 命令执行失败（如磁盘空间不足等情况），Redis 会记录错误日志，并停止执行 RDB 持久化操作。如果需要强制执行 RDB 持久化操作，可以使用 SAVE 命令或手动删除旧的 RDB 文件来释放磁盘空间。</p>
<figure>
<img onerror="imgOnError(this);" data-fancybox="gallery" src=".\295d16a4babc713cd39ebaad25df6474.png" alt="" data-caption="" loading="lazy"><figcaption>在这里插入图片描述</figcaption>
</figure>
<p><strong>AOF持久化</strong></p>
<p>快照功能并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化，将修改的每一条指令记录进文件appendonly.aof中(先写入os cache，每隔一段时间fsync到磁盘)</p>
<p>AOF打开时，redis执行的每个写操作都被记录下来，并追加到AOF文件中。AOF文件是一个日志文件，包含了在服务器上执行写操作的所有指令。当redis服务器需要恢复时，它能够通过读取AOF文件来还原出命令历史，重建完整的数据状态。这种技术称为命令回放，命令回放交换和被还原在AOF文件中的操作的属于服务器的已知落后的输出。期间，服务器不再接收任何输入，而是尝试重新执行它之前已经执行过的适量输出的效果。</p>
<p>AOF存在三种不同的策略：</p>
<ol type="1">
<li><p>always（每个命令立刻输入）</p>
<p>对于每个redis对服务器执行的命令都立即将其内容同步到aof文件中。这种方法能够保证非常高的数据安全性，因为aof文件总是包含最新的数据，但性能相对较低，可能会对性能造成一定的影响。</p></li>
<li><p>everysec（每秒钟同步一次）</p>
<p>这种方式每隔一秒钟将所有未同步的命令同步到磁盘上的aof文件中，这样可以减少硬盘io，提高性能和安全性的平衡。</p></li>
<li><p>no （让操作系统来决定何时进行同步）</p>
<p>当使用no方式时，redis会把aof缓冲区中的每条消息都直接交给系统内核来处理。内核再根据运行状态（包括机器负载、各进程等待时间等）来进行下一步操作。相对于其他两种，no方式在性能上有很大优势，但也存在最小程度的数据不可恢复风险。</p></li>
</ol>
<p><strong>RBD vs AOF</strong></p>
<figure>
<img onerror="imgOnError(this);" data-fancybox="gallery" src=".\a41c32b2cb43da4bfda010d4cb1715e9.png" alt="" data-caption="" loading="lazy"><figcaption>在这里插入图片描述</figcaption>
</figure>
<p><strong>Redis 4.0 混合持久化</strong></p>
<p>重启 Redis 时，我们很少使用 RDB来恢复内存状态，因为会丢失大量数据。我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 RDB来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。 Redis 4.0 为了解决这个问题，带来了一个新的持久化选项——混合持久化。 AOF在重写时，不再是单纯将内存数据转换为RESP命令写入AOF文件，而是将重写这一刻之前的内存做RDB快照处理，并且将RDB快照内容和增量的AOF修改内存数据的命令存在一起，都写入新的AOF文件，新的文件一开始不叫appendonly.aof，等到重写完新的AOF文件才会进行改名，覆盖原有的AOF文件，完成新旧两个AOF文件的替换。 于是在 Redis 重启的时候，可以先加载 RDB 的内容，然后再重放增量 AOF 日志就可以完全替代之前的AOF 全量文件重放，因此重启效率大幅得到提升。 简而言之：检查点重构+日志重放。每次AOF重写时将已经写入的日志重构成RDB快照，然后续写日志。从上次重写的地方开始可以直接利用RDB快照重构，然后余下的部分利用日志回放。</p>
<h4 id="缓存穿透">8.5.4 缓存穿透</h4>
<p>查询一个不存在的数据，因为mysql查询不到数据，所以不会直接写入缓存，就会导致每次请求都去查数据库。（恶意攻击者常用此手段DoS服务器IO资源）</p>
<p><strong>解决方法-缓存空数据</strong></p>
<p>查询返回的数据为空，仍把这个空结果进行缓存；</p>
<p><strong>优点</strong>：实现简单。<br>
<strong>缺点</strong>：①如果有大量查询的数据都不存在，则redis中会缓存大量空数据，这会消耗内存（这里可以给缓存添加一个TTL,减少内存消耗）；②如果原先查的数据不存在，但是后来数据库中又添加上了，可能存在数据不一致的问题。</p>
<p><strong>解决方法-布隆过滤器</strong></p>
<figure>
<img onerror="imgOnError(this);" data-fancybox="gallery" src=".\e8d626c7afb27c8f2d3bc5d097586050.png" alt="" data-caption="" loading="lazy"><figcaption>在这里插入图片描述</figcaption>
</figure>
<p><strong>优点</strong>：内存占用较少，没有多余key。<br>
<strong>缺点</strong>：①实现复杂；②存在误判。</p>
<p>布隆过滤器主要是用于检索一个元素是否在一个集合中，可以使用redisson实现布隆过滤器。 它的底层主要是先去初始化一个比较大数组，里面存放的二进制0或1。在一开始都是0，当一个key来了之后经过3次hash计算，根据计算结果找到对应数组下标，然后把数组中原来的0改为1，这样的话，三个数组的位置就能表明一个key的存在。查找的过程也是一样的。 由于hash过程没有冲突处理，所以有一定的的误判率，但是，<strong>只可能是不存在被误判为存在，而不可能是存在被误判为不存在。</strong> 原因显而易见，由hash性质决定。</p>
<h4 id="缓存雪崩">8.5.5 缓存雪崩</h4>
<p><strong>Redis缓存雪崩</strong>是指在某个特定时间段，缓存中的大部分数据都过期失效，导致大量的请求直接访问数据库，造成数据库压力过大，甚至引起数据库崩溃的情况。</p>
<p><strong>原因</strong></p>
<ol type="1">
<li><p>缓存数据同时过期；</p>
<p>大量的缓存数据在同一时间段过期，例如由于误配置或由于某些缓存服务器的故障，缓存数据无法及时更新，那么当有大量请求访问这些数据时，它们将直接落到数据库上，导致数据库请求量骤增，产生压力。</p></li>
<li><p>缓存服务器宕机；</p>
<p>缓存服务器遇到故障或宕机，所有请求将无法从缓存中获取数据，强迫它们直接访问数据库。由于缓存未能发挥作用，数据库将面临大量请求，导致性能下降，并可能导致数据库崩溃。</p></li>
</ol>
<p><strong>解决方案</strong></p>
<ol type="1">
<li><p>设置合理的缓存过期时间 缓存过期时间的设置需要根据业务需求和数据的变化频率来确定。对于不经常变化的数据，可以设置较长的过期时间，以减少对数据库的频繁访问。对于经常变化的数据，可以设置较短的过期时间，确保缓存数据的实时性。 注意的是，缓存过期时间设置过长可能导致数据的实时性降低，而设置过短可能增加缓存失效和数据库压力。因此，需要根据具体应用场景和需求来综合考虑，进行合理的设置。</p></li>
<li><p>使用热点数据预加载 预先将热点数据加载到缓存中，并设置较长的过期时间，可以避免在同一时间点大量请求直接访问数据库。可以根据业务需求，在系统启动或低峰期进行预热操作，将热点数据提前加载到缓存中。 热点数据预加载可以提升系统的性能和响应速度，减轻数据库的负载。要注意的是，预加载操作可能会占用系统资源，因此需要合理安排预加载执行的时间和频率，避免对系统正常业务的影响。另外，需要根据实际情况监控和调整预加载策略，以保持缓存数据的实时性和准确性。</p></li>
<li><p>缓存数据分布均衡 将缓存数据进行分散存储，可以使用一致性哈希算法或数据分片来将缓存数据分散存储在多个缓存服务器上，避免将所有数据集中存储在同一台缓存服务器上。这样可以提高系统的容错性，避免某个缓存服务器故障导致大量的缓存失效。通过合理的数据分布策略和动态的节点管理，可以确保缓存数据在不同节点之间均衡分布，提高系统的性能和可扩展性。</p></li>
<li><p>使用多级缓存架构 使用多级缓存架构可以提高系统的性能和容错性。内存缓存（如Redis）可以提供快速的数据访问能力，而分布式缓存（如Memcached）可以通过多台服务器组成集群，提高系统的可用性。可以根据数据的访问频率和重要程度，将数据存储在不同级别的缓存中。 使用多级缓存架构可以根据数据的访问频率和重要性，将数据存储在不同级别的缓存中，以提高数据访问的速度和稳定性。同时，通过合理的缓存策略和同步机制，保证多级缓存中的数据的实时性和一致性。综合考虑业务需求和技术条件，可以选择适合的多级缓存架构来提升系统的性能和用户体验。</p></li>
<li><p>缓存故障转移和降级策略 当缓存服务器发生故障或宕机时，需要有相应的故障转移和降级策略。可以通过监控系统来及时发现缓存故障，并进行自动切换到备份缓存服务器。同时，可以实现降级策略，当缓存失效时，系统可以直接访问数据库，保证系统的可用性。 通过缓存故障转移和降级策略，可以保证系统在缓存不可用或故障的情况下仍然可以正常运行，提高系统的稳定性和容错性。</p></li>
</ol>
<h4 id="缓存击穿">8.5.4 缓存击穿</h4>
<p>缓存击穿就是大量请求同时查询一个key（或一批）时，此时这个key正好失效了，就会导致大量的请求都打到数据库上面去，也就是热点key突然都失效了，MySQL承受高并发量</p>
<p>简单说就是：<strong>热点key突然失效，导致MySQL被暴打</strong></p>
<p><strong>解决方案</strong></p>
<ol type="1">
<li><p>设置热点数据的永不过期策略：对于一些非常热门的数据，可以将其缓存时间设置为永不过期，这样可以避免缓存失效导致的击穿问题。但需要注意，这种方式可能会导致缓存数据不及时更新的问题。</p></li>
<li><p>互斥更新，<strong>采用双检加锁机制</strong>。即设置key值为独占资源，串行执行所有请求。（由于第一个请求查回key值后会缓存至Redis，此时其他请求直接缓存命中走人，无需在请求数据库。）</p></li>
</ol>
<h4 id="缓存预热">8.5.5 缓存预热</h4>
<p>缓存预热是指在系统启动或者高峰期之前，<strong>提前将数据加载到缓存中</strong>，避免在用户请求的时候，先查询数据库（<strong>这样第一个查询的人就会比较慢</strong>），再把查询结果回写到redis当中去。</p>
<p>ps. 8.5.4缓存穿透中的布隆过滤器在此时被构建。</p>
<figure>
<img onerror="imgOnError(this);" data-fancybox="gallery" src=".\2f7fa900d371692c0f5340992939b353.png" alt="" data-caption="" loading="lazy"><figcaption>在这里插入图片描述</figcaption>
</figure>
<h4 id="缓存降级">8.5.6 缓存降级</h4>
<p>缓存降级是指缓存失效或缓存服务器挂掉的情况下，不去访问数据库，直接返回默认数据或访问服务的内存数据。降级一般是有损的操作，所以尽量减少降级对于业务的影响程度。</p>
<p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p>
<p>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</p>
<p>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</p>
<p>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</p>
<p>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</p>
<h3 id="redis缓存和数据库的一致性">8.6 Redis缓存和数据库的一致性</h3>
<h4 id="问题">8.6.1 问题</h4>
<p>如何保证 Redis 缓存和数据库一致性？</p>
<ul>
<li>到底是更新缓存还是删除缓存？</li>
<li>到底选择先更新数据库，再删除缓存，还是先删除缓存，再更新数据库？</li>
</ul>
<h4 id="缓存的引入">8.6.2 缓存的引入</h4>
<p>前期业务正处在开始阶段，流量非常小，当客户端请求过来，无论是读请求还是写请求，直接操作数据库就可以，前期架构框架如下图。</p>
<figure>
<img onerror="imgOnError(this);" data-fancybox="gallery" src=".\870748518224ec5e05be920bf0f93937.png" alt="" data-caption="" loading="lazy"><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>但是随着业务量的增长，项目请求量越来越大，这时如果每次都从数据库中读数据，就会出现大问题了。这个时候我们项目通常都会引入缓存来提高读性能，架构框架如下图。</p>
<figure>
<img onerror="imgOnError(this);" data-fancybox="gallery" src=".\33d90d385e42686c4adbd99a0f2d38b3.png" alt="" data-caption="" loading="lazy"><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>这个实现方式如果有请求过来，所有读请求都可以直接从缓存中读取到数据，不需要再查数据库，性能非常高。</p>
<p>但是会存在以下2点问题：</p>
<ol type="1">
<li><p>不设置过期时间，不经常访问的数据还存在缓存中</p></li>
<li><p>因为是定时执行同步数据，会导致缓存和数据库的数据不一致的问题（看任务执行的频率）</p></li>
</ol>
<p>这种方式适合数据量小，对数据一致性要求不高的业务场景。</p>
<p>想要缓存利用率最大化，我们很容易想到的方案是，缓存中只保留最近访问的热数据。具体要怎么做呢？如下几点：</p>
<ul>
<li>写请求只写数据库</li>
<li>读请求首先读缓存，如果缓存中不存在，再从数据库中读取，并更新到缓存</li>
<li>写入缓存中的数据，都设置失效时间</li>
</ul>
<figure>
<img onerror="imgOnError(this);" data-fancybox="gallery" src=".\6abc4b8a7d96f6312bb12383fdf19b9f.png" alt="" data-caption="" loading="lazy"><figcaption>在这里插入图片描述</figcaption>
</figure>
<h4 id="缓存一致性问题">8.6.3 缓存一致性问题</h4>
<p>当数据发生更新时，我们不仅要操作数据库，还要一并操作缓存。具体操作就是，修改一条数据时，不仅要更新数据库，也要连带缓存一起更新。</p>
<p>如果缓存和数据库都更新的话，就会存在以下两个问题：</p>
<ul>
<li>是先更新数据库还是后更新缓存</li>
<li>是先更新缓存还是后更新数据库</li>
</ul>
<p><strong>异常导致的一致性问题</strong></p>
<ol type="1">
<li><p>先更新数据库，后更新缓存 首先执行数据库更新的操作并且成功了，这时再去更新缓存并且失败了，那么此时数据库中是最新的值，而缓存中还是旧的数据值。如果一个读请求过来，首先读取缓存中的数据，这时都是旧值，只有当缓存过期失效后，才能重新在数据库中得到新的值。</p></li>
<li><p>先更新缓存，后更新数据库 首先执行缓存更新的操作并且成功了，这时再去更新数据库并且失败了，那么此时缓存中是最新的值，而数据库中还是旧的数据值。虽然此时读请求可以命中缓存，拿到正确的值，但是缓存过期失效以后就会从数据库中读取到旧值，重新同步缓存也是这个旧值。</p></li>
</ol>
<p><strong>并发导致的一致性问题</strong></p>
<ol type="1">
<li>线程 A 更新数据库（X = 1）</li>
<li>线程 B 更新数据库（X = 2）</li>
<li>线程 B 更新缓存（X = 2）</li>
<li>线程 A 更新缓存（X = 1）</li>
</ol>
<h4 id="解决方案">8.6.4 解决方案</h4>
<p><strong>缓存单删</strong></p>
<p>即业界俗称的缓存删除模式。在更新数据前<strong>先删除缓存</strong>；然后再<strong>更新库</strong>，每次查询的时候发现缓存无数据，再从库里加载数据放入缓存。</p>
<p>优点</p>
<ul>
<li>此种实现方案简单</li>
<li>无需依赖三方中间件</li>
<li>缓存中的数据<strong>基本</strong>能和库里的数据<strong>保持一致</strong></li>
</ul>
<p>缺点</p>
<ul>
<li>缓存逻辑和正常业务逻辑耦合在一起</li>
<li>在高并发的读流量下，还是会存在缓存和库里的数据不一致。见下图</li>
</ul>
<figure>
<img onerror="imgOnError(this);" data-fancybox="gallery" src=".\b108eec7e943a165af1580fb6d39ad08.png" alt="" data-caption="" loading="lazy"><figcaption>在这里插入图片描述</figcaption>
</figure>
<p><strong>延时双删</strong></p>
<p>延迟双删其实是为了解决缓存单删，在高并发读情况下，数据不一致的问题。具体过程为： 操作数据前，<strong>先删除缓存</strong>；接着<strong>更新DB</strong>；然后<strong>延迟一段时间</strong>，<strong>再删除缓存</strong>。</p>
<p>优点</p>
<p>1、技术架构上简单<br>
2、不依赖三方中间件<br>
3、操作速度上挺快的，直接操作DB和缓存<br>
缺点</p>
<p>1、落地难度有点大，主要是延迟时间太不好确认了<br>
2、缓存操作逻辑和业务逻辑进行了耦合</p>
<p>极端情况仍有问题：</p>
<figure>
<img onerror="imgOnError(this);" data-fancybox="gallery" src=".\4107bb0153180128da94d25f74b24a92.png" alt="" data-caption="" loading="lazy"><figcaption>在这里插入图片描述</figcaption>
</figure>
<p><strong>定时+增量更新</strong></p>
<p>定时更新+增量查询：主要是利用库里行数据的<strong>更新时间</strong>字段+<strong>定时增量查询</strong>。</p>
<p>具体为：每次更新库里的行数据，记录当前行的更新时间；然后把更新时间做为一个索引字段。定时任务：会每隔5秒钟（间隔时间可自定义）；把库里最近更新5秒钟的数据查询出来；然后放入缓存，并记录本次查询结束时间。</p>
<p>优点</p>
<p>1、实现方案，和架构很简单<br>
2、也能把缓存逻辑和业务逻辑进行解耦</p>
<p>缺点</p>
<p>1、数据库里的数据和缓存中数据，会在极短时间内，存在不一致，但最终会是一致的。这个极短的时间，取决于定时调度间隔时间，一般在秒级。<br>
2、如果是<strong>分库分表</strong>的业务，编写这个<strong>查询逻辑</strong>，估计会稍显<strong>复杂</strong>。</p>
<p><strong>监听binlog+MQ</strong></p>
<p>通过监听数据库(比如mysql <strong>binlog</strong>)；通过binlog把数据库数据的更新操作日志（比如insert,update,delete），采集到后，通过MQ的方式，把数据同步给下游对应的消费者；下游消费者拿到数据的操作日志并拿到对应的业务数据后，再放入缓存。</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src=".\87b2fdb76a3afd96c013497abc23aa22.png" alt="在这里插入图片描述" data-caption="在这里插入图片描述" loading="lazy"> 优点</p>
<p>1、把操作缓存的代码逻辑，从正常的业务逻辑里<strong>解耦</strong>出来；业务代码更加清爽和简洁，两者互不干扰和影响，独立发展。用非人类的话说，<strong>减少</strong>对<strong>业务代码</strong>的<strong>侵入性</strong>。<br>
2、曾经有幸在大厂里实践过此种方案，速度还贼快，虽然从库到缓存经过了类canal和mq中间件，但基本上耗时都是在毫秒级，99.9%都是10毫秒内能完成库里的数据和缓存数据同步（大厂的优势出来了）</p>
<p>缺点</p>
<p>1、技术方案和架构，非常<strong>复杂</strong><br>
2、中间件的运维和维护，是个不小的工作量<br>
3、由于引入了MQ需要解决引入MQ后带来的问题。比如数据乱序问题：同一条数据<strong>先发后至，后发先至</strong>的到达消费者后，从而引起的<strong>MQ乱序</strong>消费问题，但一般都能解决。</p>
<p><strong>总结</strong></p>
<figure>
<img onerror="imgOnError(this);" data-fancybox="gallery" src=".\684aacc5b70e52d4b6327b9a0a8550e9.png" alt="" data-caption="" loading="lazy"><figcaption>在这里插入图片描述</figcaption>
</figure>
<h3 id="主从复制-1">8.7 主从复制</h3>
<h4 id="概念-5">8.7.1 概念</h4>
<p>Redis 的主从复制是指将一个 Redis 实例（称为主节点）的数据复制到其他 Redis 实例（称为从节点）的过程。主从复制可以实现数据备份、读写分离、负载均衡等功能。</p>
<p>主机数据更新后根据配置和策略，自动同步到从机的 master/slave 机制，Master 以写为主，Slave 以读为主。主少从多、主写从读、读写分离、主写同步复制到从。</p>
<p><strong>作用（为什么要主从复制？）</strong></p>
<p>1.数据的热备份 2.故障恢复：在主服务器挂掉的时候，从服务器可以顶替过来 3.负载均衡：读写分离，写数据可以主服务器来做，读操作从服务器来操作 备注：主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</p>
<h4 id="主从复制方式">8.7.2 主从复制方式</h4>
<p>在 Redis 主从复制中，主节点负责接收客户端的写操作，并将其同步到从节点。从节点只能接收读操作请求，不能进行写操作。主节点将数据同步到从节点的方式有两种：</p>
<p><strong>全量复制</strong> 主节点将所有数据发送给从节点进行复制，适用于从节点第一次复制数据或者从节点数据丢失需要重新复制的情况。</p>
<figure>
<img onerror="imgOnError(this);" data-fancybox="gallery" src=".\492d331da74d3ac366f4357205c1907f.png" alt="" data-caption="" loading="lazy"><figcaption>在这里插入图片描述</figcaption>
</figure>
<p>全量复制是非常重型的操作的具体表现在下面几点：</p>
<p>（1）主节点通过bgsave命令fork子进程进行RDB持久化，该过程是非常消耗CPU、内存(页表复制)、硬盘IO的</p>
<p>（2）主节点通过网络将RDB文件发送给从节点，对主从节点的带宽都会带来很大的消耗</p>
<p>（3）从节点清空老数据、载入新RDB文件的过程是阻塞的，无法响应客户端的命令；如果从节点执行bgrewriteaof，也会带来额外的消耗</p>
<p>ps.全量复制走的是AOF持久化流程</p>
<p><strong>增量复制</strong> 主节点只发送最新的修改数据给从节点进行复制，适用于从节点已经复制过数据，只需要同步最新数据的情况。 <img onerror="imgOnError(this);" data-fancybox="gallery" src=".\cd8fbe0103a6038be91ae140a4fb3250.png" alt="在这里插入图片描述" data-caption="在这里插入图片描述" loading="lazy"></p>
<p>过程如下：</p>
<p>首先，从节点根据当前状态，决定如何调用psync命令：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1.</span>如果从节点之前未执行过slveof或最近执行了slaveof no one，则从节点发送命令为psync ? -<span class="hljs-number">1</span>，向主节点请求全量复制；<br><span class="hljs-number">2.</span>如果从节点之前执行了slaveof，则发送命令为psync &lt;runid&gt; &lt;offset&gt;，其中runid为上次复制的主节点的runid，offset为上次复制截止时从节点保存的复制偏移量。<br></code></pre></td></tr></table></figure>
<p>复制</p>
<p>其次，主节点根据收到的psync命令，及当前服务器状态，决定执行全量复制还是部分复制：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1.</span>如果主节点版本低于<span class="hljs-title class_">Redis2</span><span class="hljs-number">.8</span>，则返回-<span class="hljs-variable constant_">ERR</span>回复，<br>此时从节点重新发送sync命令执行全量复制；<br><span class="hljs-number">2.</span>如果主节点版本够新，且runid与从节点发送的runid相同，<br>且从节点发送的offset之后的数据在复制积压缓冲区中都存在，<br>则回复+<span class="hljs-variable constant_">CONTINUE</span>，表示将进行部分复制，从节点等待主节点发送其缺少的数据即可；<br><span class="hljs-number">3.</span>如果主节点版本够新，但是runid与从节点发送的runid不同，<br>或从节点发送的offset之后的数据已不在复制积压缓冲区中(在队列中被挤出了)，<br>则回复+<span class="hljs-variable constant_">FULLRESYNC</span> &lt;runid&gt; &lt;offset&gt;，表示要进行全量复制，<br>其中runid表示主节点当前的runid，offset表示主节点当前的offset，<br>从节点保存这两个值，以备使用。<br></code></pre></td></tr></table></figure>
<p><strong>Redis主从复制 vs Redis集群</strong></p>
<p>Redis 的主从复制和 Redis 集群都是实现高可用性的方式，但它们的实现方式和应用场景有所不同。</p>
<ol type="1">
<li>主从复制是将一个 Redis 实例（主节点）的数据复制到多个 Redis 实例（从节点）中，可以实现数据的备份和读写分离。主节点负责写操作，从节点负责读操作，可以提高读写性能。但是主从复制不能扩展写性能，因为所有的写操作都需要在主节点上执行。</li>
<li>Redis 集群是将多个 Redis 实例组成一个集群，每个实例负责部分数据，可以实现数据的分片存储和负载均衡。不同的实例负责不同的数据，可以提高写操作的性能。同时， Redis 集群还可以实现自动故障转移，当某个实例出现故障时，集群会自动将该实例的数据迁移到其他实例上，保证数据的可用性。</li>
</ol>
<p>因此，主从复制适用于读多写少的场景，而 Redis 集群适用于读写都比较频繁的场景。如果需要提高读写性能和数据的可用性，可以采用主从复制和 Redis 集群的组合方式。</p>
<p>参考文献</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43728884/article/details/130394749">Redis持久化机制看这一篇就够了！-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/shintyan/article/details/121889827?spm=1001.2014.3001.5502">字节面试杂谈——MySQL、Redis_redis数据库使用的memery数据引擎嘛-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/a342874650/article/details/134985469">Redis知识详解（超详细）-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/guorui_java/article/details/117194603">redis面试题总结（附答案）-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/651758438?utm_id=0">万字长文解析如何基于Redis实现消息队列 - 知乎 (zhihu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/redis/redis-stream.html">Redis Stream | 菜鸟教程 (runoob.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/rqj/article/details/126345843">深入了解下 「Redis 发布/订阅机制」的原理与实战运用_redis订阅发布的实际应用-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/contact97/article/details/132105711">Redis实战（5）——Redis实现消息队列_redis消息队列实现-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/jia970426/article/details/130611163">【Redis】IO多路复用机制_redis io多路复用-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_9928699/5255648">「Clickhouse系列」分布式表&amp;本地表详解_51CTO博客_clickhouse 分布式表</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Ra41167f3/?p=4&amp;spm_id_from=pageDriver&amp;vd_source=78903d53162ecc89ed87d978c4fc65cb">ClickHouse之存储格式揭秘_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_58121644/article/details/130779251">数据库的三大设计范式和BCNF_bcnf范式-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_36829761/article/details/136092780">BCNF 范式详解-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42131383/article/details/125338068">聚簇索引和非聚簇索引-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_26347283/article/details/134134528">当前读和快照读-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_50651363/article/details/119747515">悲观锁和乐观锁的区别_乐观锁和悲欢锁的区别-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/CAP%E5%8E%9F%E5%88%99/5712863?fr=ge_ala">CAP原则_百度百科 (baidu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Redamancy06/article/details/126858042">数据库并发控制、事物的四大特性、原子性、一致性、隔离性、持久性，简称ACID、事物的概念、数据概念（脏读，不可重复读，幻读)、封锁协议、一级封锁协议、二级封锁协议、三级封锁协议、最强封锁协议_数据库 原子性 隔离性-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40980718/article/details/131054600">【Redis篇】Redis缓存之缓存穿透-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/CJPSR/article/details/131848434">Redis--缓存雪崩及解决方案_redis缓存雪崩-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/flyingcloud6/article/details/132253103">Redis 之 缓存预热 &amp; 缓存雪崩 &amp; 缓存击穿 &amp; 缓存穿透-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2185988">面试必问：缓存预热、降级？-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2109750?areaSource=106000.13&amp;traceId=qTu901NQ17UnI8HOF34EV">RAID0、RAID1、RAID5、RAID6、RAID10、RAID50的异同与应用-腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wuhuayangs/article/details/121971205">如何保证 Redis 缓存与数据库双写一致性？看这篇就够了_redis如何保证缓存和数据库一致性-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/salmonwilliam/article/details/135438774">redis 如何保证缓存和数据库一致性_reidis如何保证数据和缓存一致性-CSDN博客</a></p>

    
  </article>

  
      
    <div class="nexmoe-post-copyright">
        <strong>本文作者：</strong>Kalzn<br>
        <strong>本文链接：</strong><a href="http://kalzncc.github.io/2024/04/09/137570823/" title="http:&#x2F;&#x2F;kalzncc.github.io&#x2F;2024&#x2F;04&#x2F;09&#x2F;137570823&#x2F;" target="_blank" rel="noopener">http:&#x2F;&#x2F;kalzncc.github.io&#x2F;2024&#x2F;04&#x2F;09&#x2F;137570823&#x2F;</a><br>
        
            <strong>版权声明：</strong>本文采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/cn/deed.zh" target="_blank">CC BY-NC-SA 3.0 CN</a> 协议进行许可 <div><strong>除此之外，本文不做正确性担保，本人不对产生的问题负责。</strong></div>
        
        
    </div>


  
  
  <!-- <div class="nexmoe-post-meta nexmoe-rainbow">
   
    
        <a class="nexmoefont icon-tag-fill -none-link" href="/tags/%E5%85%AB%E8%82%A1/" rel="tag">八股</a>
    
</div> -->

  
      <div class="nexmoe-post-footer">
          评论区建设中
      </div>
  
</div>
            <div class="nexmoe-post-right">
              <div class="nexmoe-fixed">
                  <div class="nexmoe-tool"> 
                    
                      
                        
                          
                          
                              <button class="mdui-fab catalog" style="overflow:unset;">
                                  <i class="nexmoefont icon-i-catalog"></i>
                                  <div class="nexmoe-toc">
                                      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">1.</span> <span class="toc-text">0.数据完整性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">1.数据库并发控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E7%89%A9"><span class="toc-number">2.1.</span> <span class="toc-text">1.1事物</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E8%AF%BB%E5%86%99%E9%94%99%E8%AF%AF"><span class="toc-number">2.2.</span> <span class="toc-text">1.2 并发读写错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">2.3.</span> <span class="toc-text">1.3 锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">2.3.1.</span> <span class="toc-text">1.3.1 乐观锁与悲观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E6%8E%92%E4%BB%96%E9%94%81"><span class="toc-number">2.3.2.</span> <span class="toc-text">1.3.2 共享锁和排他锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E9%94%81%E4%B8%8E%E8%A1%A8%E9%94%81"><span class="toc-number">2.3.3.</span> <span class="toc-text">1.3.3 行锁与表锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-number">2.3.4.</span> <span class="toc-text">1.3.4 意向锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">2.4.</span> <span class="toc-text">1.4 封锁协议与隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mvcc"><span class="toc-number">2.5.</span> <span class="toc-text">1.5 MVCC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">2.6.</span> <span class="toc-text">1.5.1 概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E8%AF%BB%E4%B8%8E%E5%BF%AB%E7%85%A7%E8%AF%BB"><span class="toc-number">2.6.1.</span> <span class="toc-text">1.5.2 当前读与快照读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mvcc-in-innodb"><span class="toc-number">2.6.2.</span> <span class="toc-text">1.5.3 MVCC in InnoDB</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">2. 数据库范式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9Fcap%E5%AE%9A%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">3.分布式系统CAP定理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%81%BE%E5%A4%87"><span class="toc-number">5.</span> <span class="toc-text">4.灾备</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A1%86%E6%9E%B6%E4%B8%8E%E5%BC%95%E6%93%8E"><span class="toc-number">6.</span> <span class="toc-text">5.Mysql数据库框架与引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql-framework"><span class="toc-number">6.1.</span> <span class="toc-text">5.1 Mysql Framework</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%86%E6%9E%B6"><span class="toc-number">6.1.1.</span> <span class="toc-text">5.1.1 框架</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#innodb-myisam"><span class="toc-number">6.1.2.</span> <span class="toc-text">5.1.2 InnoDB &amp; MyISAM</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lock-in-mysql"><span class="toc-number">6.2.</span> <span class="toc-text">5.2 Lock in Mysql</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95"><span class="toc-number">6.3.</span> <span class="toc-text">5.3 数据库索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95innodb%E5%92%8C%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95myisam"><span class="toc-number">6.3.1.</span> <span class="toc-text">5.3.1 聚簇索引（InnoDB）和非聚簇索引（MyISAM）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">6.3.2.</span> <span class="toc-text">5.3.2 索引数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB%E6%80%BB%E7%BB%93"><span class="toc-number">6.3.3.</span> <span class="toc-text">5.3.3 索引分类总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%8F%AF%E7%94%A8%E6%80%A7"><span class="toc-number">6.3.4.</span> <span class="toc-text">5.3.4 索引可用性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">6.4.</span> <span class="toc-text">5.4 主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">6.4.1.</span> <span class="toc-text">5.4.1 概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#binlog"><span class="toc-number">6.4.2.</span> <span class="toc-text">5.4.2 Binlog</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">6.4.3.</span> <span class="toc-text">5.4.3 主从复制的流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="toc-number">6.4.4.</span> <span class="toc-text">5.4.4 数据库读写分离</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%BB%B6%E8%BF%9F"><span class="toc-number">6.4.5.</span> <span class="toc-text">5.4.5 主从同步延迟</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E6%89%A7%E8%A1%8C%E5%88%86%E6%9E%90"><span class="toc-number">6.5.</span> <span class="toc-text">5.5 MySQL执行分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mysql%E5%9F%BA%E6%9C%AC%E6%89%A7%E8%A1%8C%E6%A1%86%E6%9E%B6"><span class="toc-number">6.5.1.</span> <span class="toc-text">5.5.1 MySql基本执行框架</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#server%E5%B1%82"><span class="toc-number">6.5.2.</span> <span class="toc-text">5.5.2 Server层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#log%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.5.3.</span> <span class="toc-text">5.5.3 Log系统</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83"><span class="toc-number">7.</span> <span class="toc-text">6. 数据库设计规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">7.1.</span> <span class="toc-text">6.1 数据库命名规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83-1"><span class="toc-number">7.2.</span> <span class="toc-text">6.2 数据库设计规范</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#clickhouse"><span class="toc-number">8.</span> <span class="toc-text">7. ClickHouse</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="toc-number">8.1.</span> <span class="toc-text">7.1 概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#mpp%E6%9E%B6%E6%9E%84"><span class="toc-number">8.1.0.1.</span> <span class="toc-text">MPP架构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84"><span class="toc-number">8.1.0.2.</span> <span class="toc-text">分布式架构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dbms"><span class="toc-number">8.1.0.3.</span> <span class="toc-text">DBMS</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clickhouse%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">8.2.</span> <span class="toc-text">7.2 ClickHouse的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clickhouse%E9%AB%98%E6%95%88%E6%9F%A5%E8%AF%A2%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">8.3.</span> <span class="toc-text">7.3 ClickHouse高效查询的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clickhouse%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">8.4.</span> <span class="toc-text">7.4 ClickHouse执行过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clickhouse%E8%A1%A8%E5%BC%95%E6%93%8E"><span class="toc-number">8.5.</span> <span class="toc-text">7.5 ClickHouse表引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E6%A0%91%E5%BC%95%E6%93%8E"><span class="toc-number">8.5.1.</span> <span class="toc-text">7.5.1 合并树引擎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%BC%95%E6%93%8E"><span class="toc-number">8.5.2.</span> <span class="toc-text">7.5.2 日志引擎</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">8.6.</span> <span class="toc-text">7.6 高级数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cilckhouse-vs-%E4%BC%A0%E7%BB%9F%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">8.7.</span> <span class="toc-text">7.7 CilckHouse vs 传统关系型数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ddl-dml"><span class="toc-number">8.8.</span> <span class="toc-text">7.8 DDL &amp; DML</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9%E4%B8%8E%E7%BC%96%E7%A0%81"><span class="toc-number">8.9.</span> <span class="toc-text">7.9 数据压缩与编码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8E%8B%E7%BC%A9"><span class="toc-number">8.9.1.</span> <span class="toc-text">7.9.1 数据压缩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81"><span class="toc-number">8.9.2.</span> <span class="toc-text">7.9.2 数据编码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%93%E6%9E%84"><span class="toc-number">8.10.</span> <span class="toc-text">7.10 分布式结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%92%E8%89%B2"><span class="toc-number">8.10.1.</span> <span class="toc-text">7.10.1 角色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E8%A1%A8%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E8%A1%A8"><span class="toc-number">8.10.2.</span> <span class="toc-text">7.10.2 本地表和分布式表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E4%B8%8E%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E5%88%87%E7%89%87%E5%92%8C%E5%86%97%E4%BD%99"><span class="toc-number">8.10.3.</span> <span class="toc-text">7.10.3 数据同步与查询（数据切片和冗余）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87%E4%B8%8E%E7%B4%A2%E5%BC%95"><span class="toc-number">8.11.</span> <span class="toc-text">7.11 数据组织与索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%8C%BApartition"><span class="toc-number">8.11.1.</span> <span class="toc-text">7.11.1 分区（Partition）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%97%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">8.11.2.</span> <span class="toc-text">7.11.2 列式存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mergetree%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87%E5%92%8C%E7%B4%A2%E5%BC%95"><span class="toc-number">8.11.3.</span> <span class="toc-text">7.11.3 MergeTree的数据组织和索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E5%8C%96%E8%AE%A1%E7%AE%97"><span class="toc-number">8.11.4.</span> <span class="toc-text">7.11.4 向量化计算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E5%8C%96%E8%A7%86%E5%9B%BE"><span class="toc-number">8.12.</span> <span class="toc-text">7.12 物化视图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis"><span class="toc-number">9.</span> <span class="toc-text">8. Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E7%AE%80%E4%BB%8B%E4%B8%8E%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">9.1.</span> <span class="toc-text">8.1 Redis简介与适用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">9.2.</span> <span class="toc-text">8.2 Redis IO多路复用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-3"><span class="toc-number">9.2.1.</span> <span class="toc-text">8.2.1 概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">9.2.2.</span> <span class="toc-text">8.2.2 原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-vs-memcached"><span class="toc-number">9.3.</span> <span class="toc-text">8.3 Redis vs Memcached</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">9.4.</span> <span class="toc-text">8.4 消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-4"><span class="toc-number">9.4.1.</span> <span class="toc-text">8.4.1 概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis-channel"><span class="toc-number">9.4.2.</span> <span class="toc-text">8.4.2 Redis Channel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis-stream"><span class="toc-number">9.4.3.</span> <span class="toc-text">8.4.3 Redis Stream</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E6%9C%BA%E5%88%B6"><span class="toc-number">9.5.</span> <span class="toc-text">8.5 Redis机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redis%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5"><span class="toc-number">9.5.1.</span> <span class="toc-text">8.5.1 Redis过期删除策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6"><span class="toc-number">9.5.2.</span> <span class="toc-text">8.5.2 内存淘汰机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-number">9.5.3.</span> <span class="toc-text">8.5.3 Redis持久化机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">9.5.4.</span> <span class="toc-text">8.5.4 缓存穿透</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">9.5.5.</span> <span class="toc-text">8.5.5 缓存雪崩</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">9.5.6.</span> <span class="toc-text">8.5.4 缓存击穿</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD"><span class="toc-number">9.5.7.</span> <span class="toc-text">8.5.5 缓存预热</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%99%8D%E7%BA%A7"><span class="toc-number">9.5.8.</span> <span class="toc-text">8.5.6 缓存降级</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">9.6.</span> <span class="toc-text">8.6 Redis缓存和数据库的一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">9.6.1.</span> <span class="toc-text">8.6.1 问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%9A%84%E5%BC%95%E5%85%A5"><span class="toc-number">9.6.2.</span> <span class="toc-text">8.6.2 缓存的引入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">9.6.3.</span> <span class="toc-text">8.6.3 缓存一致性问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">9.6.4.</span> <span class="toc-text">8.6.4 解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-1"><span class="toc-number">9.7.</span> <span class="toc-text">8.7 主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-5"><span class="toc-number">9.7.1.</span> <span class="toc-text">8.7.1 概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">9.7.2.</span> <span class="toc-text">8.7.2 主从复制方式</span></a></li></ol></li></ol></li></ol>
                                  </div>
                              </button>
                          
                          
                      
                    
                      <a href="#nexmoe-content" class="toc-link" aria-label="Back To Top" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
                  </div>
              </div>
            </div>
        </div>
    </div>
    <div id="nexmoe-search-space">
	<div class="search-container">
		<div class="search-header">
			<div class="search-input-container">
				<input
					class="search-input"
					type="text"
					placeholder="搜索"
					oninput="sinput();"
				/>
			</div>
			<a class="search-close" onclick="sclose();">×</a>
		</div>
		<div class="search-body"></div>
	</div>
</div>

    
<script src="/lib/mdui_043tiny/mdui.js"></script>
<script src="/lib/fancybox/fancybox.umd.js"></script>


 

<script async src="/js/app.js?v=1732680051111"></script>



</body>

</html>
