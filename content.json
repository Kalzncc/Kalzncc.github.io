{"meta":{"title":"Kalzn的个人博客","subtitle":"","description":"","author":"Kalzn","url":"http://Kalzncc.github.io","root":"/"},"pages":[{"title":"文章归档","date":"2022-11-20T07:23:09.203Z","updated":"2022-11-20T07:23:09.203Z","comments":true,"path":"archives.html","permalink":"http://kalzncc.github.io/archives.html","excerpt":"","text":""}],"posts":[{"title":"博客改造计划","slug":"blog-reform-plan","date":"2022-11-22T03:19:06.000Z","updated":"2022-11-22T04:49:08.264Z","comments":true,"path":"2022/11/22/blog-reform-plan/","link":"","permalink":"http://kalzncc.github.io/2022/11/22/blog-reform-plan/","excerpt":"","text":"现在前面 首先感谢Nexmoe主题的开发大佬们。 本篇blog主要记录了我在构建这个博客时的一些踩坑经历和一些小改造。以供他人借鉴之。 对LaTex的支持 写机器学习比较多，难免要用到LaTex，但是我从CSDN搬运过来后发现LaTex不能渲染。遂上网查询解决方案。发现时hexo预制的渲染器不支持LaTex公式。 解决方案很多，但是很多都没有效果，不清楚为什么，这里通过多次尝试，找到了一种适用于本主题的解决方案。 这里应该先卸载原本的渲染器，安装pandoc渲染器。 12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-kramed --save 在主题的config.yml文件中添加配置。 1234# MathJaxmathjax: enable: true per_page: true 在hexo的_config.yml文件中添加配置。 123456789101112131415# mathjax:# tags: none # or &#x27;ams&#x27; or &#x27;all&#x27;# single_dollars: true # enable single dollar signs as in-line math delimiters# cjk_width: 0.9 # relative CJK char width# normal_width: 0.6 # relative normal (monospace) width# append_css: true # add CSS to pages rendered by MathJax# every_page: false # if true, every page will be rendered by MathJax regardless the `mathjax` setting in Front-mattermarkdown: plugins: - markdown-it-footnote - markdown-it-sup - markdown-it-sub - markdown-it-abbr - markdown-it-emoji - hexo-math 在每篇博客的头部添加mathjax标签。 1234---title: 示例mathjax: true--- 随后博客可以正常渲染LaTex公式。 代码高亮问题 发现代码的显示出现了问题，代码块的样式很正常，但是代码无法根据不同语言高亮。这个问题折腾了我很长时间，上网几经周折也没找出问题。网上给出的方案挨个尝试也没什么效果。最后通过以下手段解决了一半，代码可以高亮了，但是风格有些奇怪。 变更_config.yml文件配置。 123456789101112highlight: enable: true line_number: true auto_detect: false tab_replace: &#x27;&#x27; wrap: true hljs: trueprismjs: enable: false preprocess: true line_number: true tab_replace: &#x27;&#x27; 在网站头进入highlist.js脚本，一种具体做法是在主题的config.yml文件中更改配置, 在网页head标签中嵌入js。 1slotHead: &#x27;&lt;script src=&quot;//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js&quot;&gt;&lt;/script&gt;&#x27; 博客置顶 我想把一篇blog进行置顶操作，百度后，发现有个方法，就是在文章头部中添加top参数，top值越高，越靠前。但是尝试后发现没有效果。这里发现_config.yml文件中有下面属性： 遂尝试改成： 但是发现没有任何效果，在hexo文档中也没有找到有关这个参数的说明。这里在百度的指导下，找到hexo有关主页博客排序的源码位置node_mudules/hexo-generator-index/lib/generator.js，观察源码，但是忽然意识到自己不怎么会js。总之，既然无法理解，就改一下源码，手动进行排序吧。 123456789101112131415// posts.data.sort((a, b) =&gt; (b.sticky || 0) - (a.sticky || 0)); // 将源代码中的该语句注释，改成下面这样。console.warn(&quot;Kalzn:: Hexo 源码已经被修改！ hexo-generator-index/lib/generator.js 首页排序被自定义！&quot;);posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; / if(a.top == b.top) return b.date - a.date; else return b.top - a.top; &#125; else if(a.top &amp;&amp; !b.top) &#123; return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date;&#125;); 此时我们在将文章头部引入top属性，文章将以top排序，之后按照date排序。 12345---title: 示例top: 10date: 2022-11:14: 11:45:14--- 此时发现，想要置顶的blog已经出现在文章首页啦！但是有个问题，我得让别人直到这是个置顶blog呀。此时我想到了标签系统，如果这是我给文章打个置顶标签，就能看到了。但是，Nexmoe主题默认是无法在主页显示标签的（只会显示分类），所以这里对源码进行一些改写。 在主题的layout/_partial/_post/meta.ejs中添加tags的显示。 12345678910111213141516&lt;div class=&quot;nexmoe-rainbow&quot;&gt; &lt;a class=&quot;nexmoefont icon-calendar-fill&quot;&gt;&lt;%- date(page.date, &quot;YYYY年MM月DD日&quot;) %&gt;&lt;/a&gt; &lt;% if (page.categories &amp;&amp; page.categories.length)&#123; %&gt; &lt;%- list_categories(page.categories, &#123; show_count: false, class: &#x27;nexmoefont icon-appstore-fill &#x27;, style: &#x27;none&#x27;, separator: &#x27;&#x27; &#125;) %&gt; &lt;% &#125; %&gt; &lt;%- partial(&#x27;_partial/_post/word-count&#x27;, &#123;post: page&#125;) %&gt; &lt;!-- 添加label列举 --&gt; &lt;%- partial(&#x27;_partial/_post/tag&#x27;, &#123;post: page&#125;) %&gt;&lt;/div&gt; 此时，在引入置顶标签后，就可以看到了。 但是，此时我发现，在进入blog后，会在文章的上下显示两边标签（文章末的标签是原本自带的）。这里索性将文章末的标签注释，改在文章头显示标签。 在主题的layout/post.ejs中注释代码。 1234567891011&lt;% if (!page.reprint)&#123; %&gt; &lt;%- partial(&#x27;_partial/copyright&#x27;) %&gt;&lt;% &#125; %&gt;&lt;!-- &lt;%- partial(&#x27;_partial/_post/tag&#x27;) %&gt; --&gt;&lt;% if (page.comments)&#123; %&gt; &lt;div class=&quot;nexmoe-post-footer&quot;&gt; &lt;%- theme.slotComment %&gt; &lt;/div&gt;&lt;% &#125; %&gt; 大功告成。 文章图片随机显示 网上有随机显示的教程，但好像是指定一个随机显示图片的连接。我们需求是想从我自己选取的一组图片中随机选取一个。应该有解决方案，但是我懒得找了，自己动手吧！ 在主题的config.yml中添加自定的参数。 1234567background: # 既是博客的背景，又是文章默认头图 randomImage: true #开启随机图片 randomFolder: /static/pic/random_background/ #随机图片存放的文件夹 randomNumber: 9 # 随机图片的数量 path: /static/pic/back.jpg width: 1280 height: 726 在主题的layout/index.ejs中添加对改参数的支持，这里在目录下随机选取一个图片，随机的数值与位置题目对应，以保证每次生成时，同一篇文章始终对应一张图片（也可以完全随机，但是不想每次生成都把整个网站的样子完全改变一下。笑） 123456789101112131415161718192021222324&lt;a href=&quot;&lt;%- url_for(page.path) %&gt;&quot;&gt; &lt;% if (page.cover)&#123; %&gt; &lt;div class=&quot;nexmoe-post-cover mdui-ripple absolute&quot; style=&quot;padding-top: &lt;%- page.coverHeight/page.coverWidth*100 %&gt;%;&quot;&gt; &lt;img src=&quot;&lt;%- page.cover %&gt;&quot; alt=&quot;&lt;%= page.title %&gt;&quot; loading=&quot;lazy&quot;&gt; &lt;h1&gt;&lt;%= page.title %&gt;&lt;/h1&gt; &lt;/div&gt; &lt;% &#125; else if(theme.background.randomImage) &#123; randomNo = 0; for (var i =0; i &lt;page.title.length; i++) &#123; randomNo = (randomNo * 11451419 % 1000000007 + page.title.charCodeAt(i)) % 1000000007; &#125; randomNo %= theme.background.randomNumber; randomPath = theme.background.randomFolder + randomNo + &quot;.jpg&quot;; %&gt; &lt;div class=&quot;nexmoe-post-cover absolute&quot; style=&quot;padding-top: &lt;%- page.coverHeight/page.coverWidth*100 %&gt;%;&quot;&gt; &lt;img src=&quot;&lt;%- randomPath %&gt;&quot; alt=&quot;&lt;%= page.title %&gt;&quot; loading=&quot;lazy&quot;&gt; &lt;h1&gt;&lt;%= page.title %&gt;&lt;/h1&gt; &lt;/div&gt; &lt;%&#125; else&#123; %&gt; &lt;div class=&quot;nexmoe-post-cover mdui-ripple&quot;&gt; &lt;img src=&quot;&lt;%- theme.background.path %&gt;&quot; alt=&quot;&lt;%= page.title %&gt;&quot; loading=&quot;lazy&quot;&gt; &lt;h1&gt;&lt;%= page.title %&gt;&lt;/h1&gt; &lt;/div&gt; &lt;% &#125; %&gt; 同样在layout/post.ejs进行改变。 1234567891011121314151617181920212223&lt;% if (page.cover)&#123; %&gt; &lt;div class=&quot;nexmoe-post-cover absolute&quot; style=&quot;padding-top: &lt;%- page.coverHeight/page.coverWidth*100 %&gt;%;&quot;&gt; &lt;img src=&quot;&lt;%- page.cover %&gt;&quot; alt=&quot;&lt;%= page.title %&gt;&quot; loading=&quot;lazy&quot;&gt; &lt;h1&gt;&lt;%= page.title %&gt;&lt;/h1&gt; &lt;/div&gt; &lt;% &#125; else if(theme.background.randomImage) &#123; randomNo = 0; for (var i =0; i &lt;page.title.length; i++) &#123; randomNo = (randomNo * 11451419 % 1000000007 + page.title.charCodeAt(i)) % 1000000007; &#125; randomNo %= theme.background.randomNumber; randomPath = theme.background.randomFolder + randomNo + &quot;.jpg&quot;; %&gt; &lt;div class=&quot;nexmoe-post-cover absolute&quot; style=&quot;padding-top: &lt;%- page.coverHeight/page.coverWidth*100 %&gt;%;&quot;&gt; &lt;img src=&quot;&lt;%- randomPath %&gt;&quot; alt=&quot;&lt;%= page.title %&gt;&quot; loading=&quot;lazy&quot;&gt; &lt;h1&gt;&lt;%= page.title %&gt;&lt;/h1&gt; &lt;/div&gt; &lt;%&#125; else&#123; %&gt; &lt;div class=&quot;nexmoe-post-cover&quot;&gt; &lt;img src=&quot;&lt;%- theme.background.path %&gt;&quot; alt=&quot;&lt;%= page.title %&gt;&quot; loading=&quot;lazy&quot;&gt; &lt;h1&gt;&lt;%= page.title %&gt;&lt;/h1&gt; &lt;/div&gt; &lt;% &#125; %&gt; 然后创建存储随机文件的文件夹，放入对应数量的图片。图片命名从0开始，后缀是jpg。 然后开始欣赏美如画的荧妹妹吧！","categories":[{"name":"博客改造","slug":"博客改造","permalink":"http://kalzncc.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%94%B9%E9%80%A0/"}],"tags":[{"name":"置顶","slug":"置顶","permalink":"http://kalzncc.github.io/tags/%E7%BD%AE%E9%A1%B6/"},{"name":"博客","slug":"博客","permalink":"http://kalzncc.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"2021年-蓝桥c/c++ b组国赛回忆题解","slug":"lanqiao-2021-recall","date":"2022-11-20T07:08:10.000Z","updated":"2022-11-22T02:28:11.880Z","comments":true,"path":"2022/11/20/lanqiao-2021-recall/","link":"","permalink":"http://kalzncc.github.io/2022/11/20/lanqiao-2021-recall/","excerpt":"","text":"更新一下。成绩出来了，第18名。估计是H题没能拿全分，最后一个题又没有写出一个比较好的算法。 A 这个题有点坑人，因为他不是一个算法题，而是一个计算机知识题，不知道出题人出这个题的意图。。 刚拿到蒙了，但是回忆了一下，有次我手机限速，百度了一下1Mbps是多少。隐隐约约记得公式是1Mbps=0.125MB/s， 所以。。 B 利用素数筛打表，打到20210605，然后依次判定数字，以及每个数位是不是质数即可。注意这里不认为1是质数。 C 日期题，从2001.1.1枚举到2021.12.31，依次判断即可。 D dp可解。为有个节点的二叉数的最小权值。则： E 大小写转换不解释。 F 等差序列前缀和+二分，对于x，先二分出之前有多少轮。然后求和，然后加上最后不足的一轮的前缀和。 G 数位dp，令为考虑前i位二进制，已经包含j个1，且已经到达上限flag=1，或没有到达上限flag=0的个数。 H 有循环节，我认为一个长度位n的01串会在最多迭代n次后陷入一个长度不长于n的循环节中，但赛后与别人讨论，也有说这个串在最开始就会陷入一个循环节中。都没有证明。不过我写的常数很大。估计没法拿到全分。 I 线段树+区间合并。我们视左括号为+1，右括号为-1，线段树要维护。1、区间和。2、从区间左端点开始求和的区间前缀和最小值和最大值。当进行区间反转时，进行以下操作：1、打标记。2、区间和乘-1。3、区间前缀和最小值和最大值交换，并乘-1。当进行查询时，从L节点开始，二分一个最长的，前缀和全是正数的区间。一般情况下，这个区间的右段端即位所求，因为如果这个区间是最长的，那么这个区间右段端的下一个位置的前缀和一定为负，则到这个右端点的前缀和一定是0。但是有例外，就是这个区间到序列的结束，如果没有前缀和==0的，即位不可能，否则再寻找区间的最后一个0。可以二分寻找。由于是二分套线段树，所以复杂度是m是2e5，应该可以过吧。。 J 没时间了，因为要检查，直接上了，但是出考场一讨论，傻b了，因为所以第三个数直接可以出来的，于是少了10%的样例。。。","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"http://kalzncc.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"蓝桥","slug":"蓝桥","permalink":"http://kalzncc.github.io/tags/%E8%93%9D%E6%A1%A5/"}]},{"title":"线段树合并(四道例题)","slug":"segment-tree-merge-4-example","date":"2022-11-20T06:19:11.000Z","updated":"2022-11-22T02:28:20.919Z","comments":true,"path":"2022/11/20/segment-tree-merge-4-example/","link":"","permalink":"http://kalzncc.github.io/2022/11/20/segment-tree-merge-4-example/","excerpt":"","text":"顾名思义,就是合并两个同构(就是维护的区间长度一样)线段树,其实也没啥比较nb的算法,就是一个一个节点的合并,但是如果在n个要合并的线段树里,如果一共有m个元素,则配合动态开点,复杂度会均摊成一个惊人的所以,在多次合并的均摊复杂度是非常优秀的.另外线段树合并还可以和线段树分裂一起构成维护一组线段树森林的方法 我们每次合并一个点,就是综合两个线段树表示相同区间的两个节点的信息,然后整合成一个,删去另一个,这时,我们可以有一个垃圾回收处理,如下: 123//bac数组就是垃圾桶数组,如果里面有节点,就优先取出用掉,要是没有就另起新点inline int newnod() {return (cnt?bac[cnt--]:++tot);}inline void del(int p) {bac[++cnt] = p; tr[p].l = tr[p].r = tr[p].val = 0;} 合并函数可以点点进行直接合并,如果这样不方便,也可以只针对叶子节点进行直接合并,其他节点通过pushup操作得出.(总之是两个线段树所有节点都遍历一边) 例一: P4556 Vani有约会 雨天的尾巴 线段树合并模板 如题是模板题,我们讲z种不同的物资针对每个节点维护一个权值线段树(即每个节点一个).然后按照树上差分的思想,对于路径(x,y)加上z物资一件,就让x和y的权值线段树z位置加一,,lca(x,y)和fa(lca(x,y))的权值z位置减一,最后dfs一边执行线段树合并,就行啦. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define ll long longusing namespace std;const int N = 2e5 + 5;const int Z = 1e5 + 2;int n, m;int he[N], ver[N], ne[N], tot;int d[N];queue&lt;int&gt; q;int f[N][30];inline void add(int x, int y){ ver[++tot] = y; ne[tot] = he[x]; he[x] = tot;}void bfs(){ d[1] = 1; q.push(1); while (q.size()) { int te = q.front(); q.pop(); for (int i = he[te]; i; i = ne[i]) { int v = ver[i]; if (d[v]) continue; d[v] = d[te] + 1; f[v][0] = te; for (int j = 1; j &lt; 30; j++) f[v][j] = f[f[v][j - 1]][j - 1]; q.push(v); } }}int lca(int x, int y){ if (d[x] &gt; d[y]) swap(x, y); for (int i = 29; i &gt;= 0; i--) { if (d[f[y][i]] &lt; d[x]) continue; y = f[y][i]; } if (x == y) return x; for (int i = 29; i &gt;= 0; i--) if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i]; return f[x][0];}struct Node{ int l, r; int val; int id;}tr[N * 40];int cnt, top;int rt[N], bac[N*40], ans[N];inline int newnod() { return cnt ? bac[cnt--] : ++tot; }inline void del(int p) { bac[++cnt] = p; tr[p].l = tr[p].r = tr[p].val = 0; }inline void pushup(int p){ if (tr[tr[p].l].val &gt;= tr[tr[p].r].val) { tr[p].val = tr[tr[p].l].val; tr[p].id = tr[tr[p].l].id; } else { tr[p].val = tr[tr[p].r].val; tr[p].id = tr[tr[p].r].id; }}void insert(int &amp;p, int pos, int v, int l = 1, int r = Z){ if (!p) p = newnod(); if (l == r) { tr[p].val += v; tr[p].id = l; return; } int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) insert(tr[p].l, pos, v, l, mid); else insert(tr[p].r, pos, v, mid + 1, r); pushup(p);}int merge(int x, int y, int l = 1, int r = Z){ if (!x || !y) return x + y; int mid = (l + r) &gt;&gt; 1; if (l == r) tr[x].val += tr[y].val, tr[x].id = l; else { tr[x].l = merge(tr[x].l, tr[y].l, l, mid); tr[x].r = merge(tr[x].r, tr[y].r, mid + 1, r); pushup(x); } del(y); return x;}void print(int p, int l = 1, int r = Z){ cout &lt;&lt; l &lt;&lt; \" \" &lt;&lt; r &lt;&lt; \" \" &lt;&lt; tr[p].val &lt;&lt; \" \" &lt;&lt; tr[p].id &lt;&lt; endl; if (l == r) return; int mid = (l + r) &gt;&gt; 1; print(tr[p].l, l, mid); print(tr[p].r, mid + 1, r);}void dfs_mg(int cur, int fa){ for (int i = he[cur]; i; i = ne[i]) { int y = ver[i]; if (y == fa) continue; dfs_mg(y, cur); rt[cur] = merge(rt[cur], rt[y]); } if (tr[rt[cur]].val) ans[cur] = tr[rt[cur]].id; return;}int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt; n; i++) { int x, y; scanf(\"%d%d\", &amp;x, &amp;y); add(x, y); add(y, x); } bfs(); while (m--) { int x, y, t; scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;t); insert(rt[x], t, 1); insert(rt[y], t, 1); int _lca = lca(x, y); insert(rt[_lca], t, -1); insert(rt[f[_lca][0]], t, -1); } dfs_mg(1, 0); for (int i = 1; i &lt;= n; i++) printf(\"%d\\n\", ans[i]); return 0;} 例二: P1600 天天爱跑步 这个题写了很长时间,想了半天,才从之前做的一个题里收到启发,观察这个题,如果我们对每一个点都针对n秒维护一个权值线段树,那么,针对一个路路径,线段树向父节点合并就有两种情况: &gt;1.路径是从子节点到父节点,这时,我们必须要让子节点线段树的所有元素都\"整体向前移一位\",即1秒的数量变成2秒的数量,2秒的数量变成3秒的数量....依次类推 &gt;2.路径是从父节点到子节点,这时,我们必须要让子节点线段树的所有元素都\"整体向后移一位\",即2秒的数量变成1秒的数量,3秒的数量变成2秒的数量....依次类推 但是这种操作很难在极短时间内进行,这时我们不如建立一个整体值,针对1情况,我们每上一层值都加一,我们往线段树中压入的是形式值,而实际值为+形式值,比如,在一层某个节点的值为6,这时我们在这里压入一个0秒,我们修改该点的权值线段树,但是不是让0位置+1,而是让位置加一,因为-6是这一层0的形式值.这时我们往上走两层,这时值等于8,此时我们查询2秒的个数,这时我们其实是查2秒在这一层的形式值的个数,即,这时我们在前插入的0秒,在这产生了影响,总而言之,我们在一个点插入形式值后,这个形式值,会依据整体值的不同在各层产生不同影响.然后我们必须让这课树的每一层的值统一,我们发现树的深度是一个比较好的天然值.于是乎,针对每个路径我们拆成两部分和分别依据差分思想插入树中,然后按照不同的值规则合并两边就ok啦! 123456insert(rt[x], idn(0-dep2(x)), 1);insert(rt[f[_lca][0]], idn(0-dep2(x)), -1);//第一部分tt = dep1[x] - dep1[_lca]) + (dep1[y] - dep1[_lca];//路径长度insert(rt[y], idn(tt-dep1[y]), 1);insert(rt[_lca], idn(tt-dep1[y]), -1);//第二部分 ps.这可能是迄今为止自己琢磨出的最震撼的算法了QAQ 下面是ac代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define ll long long#define max(x, y) ((x)&gt;(y)?(x):(y))using namespace std;const int N = 6e5 + 5;const int Z = 6e5 + 5;int n, m;int he[N], ver[N], ne[N], tot;int dep1[N], deep;int d[N];int q[N], qh, ql;int f[N][30];inline void add(int x, int y){ ver[++tot] = y; ne[tot] = he[x]; he[x] = tot;}inline int idn(int n) {return n + 3e5+5;}inline int dep2(int n) {return deep - dep1[n];}void bfs(){ d[1] = 1; q[++qh] = 1; while (qh &gt; ql) { int te = q[++ql]; for (int i = he[te]; i; i = ne[i]) { int v = ver[i]; if (d[v]) continue; d[v] = d[te] + 1; f[v][0] = te; for (int j = 1; j &lt; 30; j++) f[v][j] = f[f[v][j - 1]][j - 1]; dep1[v] = dep1[te] + 1; deep = max(dep1[v], deep); q[++qh] = v; } }}int lca(int x, int y){ if (d[x] &gt; d[y]) swap(x, y); for (int i = 29; i &gt;= 0; i--) { if (d[f[y][i]] &lt; d[x]) continue; y = f[y][i]; } if (x == y) return x; for (int i = 29; i &gt;= 0; i--) if (f[x][i] != f[y][i]) x = f[x][i], y = f[y][i]; return f[x][0];}struct Node{ int l, r; int val;}tr[N * 40];int cnt, top;int rt[N], bac[N*40];inline int newnod() { return cnt ? bac[cnt--] : ++top; }inline void del(int p) { bac[++cnt] = p; tr[p].l = tr[p].r = tr[p].val = 0; }void insert(int &amp;p, int pos, int v, int l = 1, int r = Z){ if (!p) p = newnod(); tr[p].val += v; if (l == r) return; int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) insert(tr[p].l, pos, v, l, mid); else insert(tr[p].r, pos, v, mid + 1, r);}int merge(int x, int y, int l = 1, int r = Z){ if (!x || !y) return x + y; tr[x].val += tr[y].val; int mid = (l + r) &gt;&gt; 1; tr[x].l = merge(tr[x].l, tr[y].l, l, mid); tr[x].r = merge(tr[x].r, tr[y].r, mid + 1, r); del(y); return x;}int qt[N], ans[N];bool flag = 0;int ask(int p, int k, int l = 1, int r = Z){ if (l == r) return tr[p].val; int mid = (l + r) &gt;&gt; 1; if (k &lt;= mid) return ask(tr[p].l, k, l, mid); else return ask(tr[p].r, k, mid+1, r);}void dfs_mg(int cur, int fa){ for (int i = he[cur]; i; i = ne[i]) { int y = ver[i]; if (y == fa) continue; dfs_mg(y, cur); rt[cur] = merge(rt[cur], rt[y]); } int tt = qt[cur]; ans[cur] += ask(rt[cur], idn(tt - (flag ? dep1[cur] : dep2(cur)))); return;}struct qy{ int lca, y; int lca_m, y_m;}qr[N];int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt; n; i++) { int x, y; scanf(\"%d%d\", &amp;x, &amp;y); add(x, y); add(y, x); } bfs(); for (int i = 1; i &lt;= n; i++) scanf(\"%d\", &amp;qt[i]); for (int i = 1; i &lt;= m; i++) { int x, y; scanf(\"%d%d\", &amp;x, &amp;y); int _lca = lca(x, y); insert(rt[x], idn(0-dep2(x)), 1); insert(rt[f[_lca][0]], idn(0-dep2(x)), -1); qr[i].lca = _lca; qr[i].y = y; qr[i].y_m = (dep1[x] - dep1[_lca]) + (dep1[y] - dep1[_lca]); } dfs_mg(1, 0); cnt = top = 0; for (int i = 0; i &lt; N * 40; i++) tr[i].l = tr[i].r = tr[i].val = 0; memset(rt, 0, sizeof(rt)); for (int i = 1; i &lt;= m; i++) { int y = qr[i].y, _lca = qr[i].lca; int tt = qr[i].y_m; insert(rt[y], idn(tt-dep1[y]), 1); insert(rt[_lca], idn(tt-dep1[y]), -1); } flag = 1; dfs_mg(1, 0); for (int i = 1; i &lt;= n; i++) printf(\"%d \", ans[i]); puts(\"\"); return 0;} 例三:P3224 [HNOI2012]永无乡 一个模板中的模板了.结合并查集找根即可. 下面是ac代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define ll long longusing namespace std;const int N = 2e5 + 5;int fa[N];int fi(int x){ if (x == fa[x]) return x; return fa[x] = fi(fa[x]);}struct Node{ int l, r; int val;}tr[N * 40];int cnt, top;int rt[N], bac[N*40];inline int newnod() { return cnt ? bac[cnt--] : ++top; }inline void del(int p) { bac[++cnt] = p; tr[p].l = tr[p].r = tr[p].val = 0; }int n, m;void insert(int &amp;p, int pos, int v, int l = 1, int r = n){ if (!p) p = newnod(); tr[p].val += v; if (l == r) return; int mid = (l + r) &gt;&gt; 1; if (pos &lt;= mid) insert(tr[p].l, pos, v, l, mid); else insert(tr[p].r, pos, v, mid + 1, r);}int merge(int x, int y, int l = 1, int r = n){ if (!x || !y) return x + y; int mid = (l + r) &gt;&gt; 1; tr[x].val += tr[y].val; tr[x].l = merge(tr[x].l, tr[y].l, l, mid); tr[x].r = merge(tr[x].r, tr[y].r, mid + 1, r); del(y); return x;}void mmerge(int x, int y){ fa[y] = x; rt[x] = merge(rt[x], rt[y]);}int ask(int p, int k, int l = 1, int r = n){ if (l == r) return l; int mid = (l + r) &gt;&gt; 1; if (tr[tr[p].l].val &gt;= k) return ask(tr[p].l, k, l, mid); else return ask(tr[p].r, k - tr[tr[p].l].val, mid+1, r);}void Debug_print(int p, int l = 1, int r = n){ cout &lt;&lt; l &lt;&lt; \" \" &lt;&lt; r &lt;&lt; \" \" &lt;&lt; tr[p].val &lt;&lt; endl; if (l == r) { return;} int mid = (l + r) &gt;&gt; 1; Debug_print(tr[p].l, l, mid); Debug_print(tr[p].r, mid + 1, r);}void De(){ for (int i = 1; i &lt;= n; i++) cout &lt;&lt; fa[i] &lt;&lt; \" \"; cout &lt;&lt; endl; for (int i = 1; i &lt;= n; i++) { cout &lt;&lt; \"--------------\" &lt;&lt; endl; cout &lt;&lt; i &lt;&lt; endl; for (int j = 1; j &lt;= n; j++) Debug_print(rt[i], j); cout &lt;&lt; \"\\n--------------\" &lt;&lt; endl; }}int _rank[N];int main(){ cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i++) { fa[i] = i; int te; scanf(\"%d\", &amp;te); insert(rt[i], te, 1); _rank[te] = i; } while(m--) { int x, y; scanf(\"%d%d\", &amp;x, &amp;y); x = fi(x); y = fi(y); if (x != y) mmerge(x, y); } int q; cin &gt;&gt; q; while(q--) { char op[5]; int x, y; scanf(\"%s%d%d\", op, &amp;x, &amp;y); if (op[0] == 'Q') { x = fi(x); if (tr[rt[x]].val &lt; y) {puts(\"-1\"); continue;} int te = ask(rt[x], y); printf(\"%d\\n\", _rank[te]); } else { x = fi(x); y = fi(y); if (x != y) mmerge(x, y); } } return 0;} 补充一例:CF600E Lomsat gelral 这个题可以用dsu来做,但是今天发现可以用线段树合并也可以!啊啊啊,这些神奇的算法还是这么的神奇,个人觉得线段树合并比dsu还要好理解一点. 下面是ac代码: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#define ll long long #define int llusing namespace std;const int N = 1e5+5;int top, cnt, tot;int bac[N*40], ver[N&lt;&lt;1], he[N], ne[N&lt;&lt;1], rt[N];int su[N];int n;struct Node{ int l, r; ll val, ans;}tr[N*40];inline int neww() { return cnt ? bac[cnt--] : ++top; }inline void del(int p) { bac[++cnt]; tr[p].l = tr[p].r = tr[p].val = 0; } void add(int x, int y){ ver[++tot] = y; ne[tot] = he[x]; he[x] = tot;}inline void pushup(int p){ if (tr[tr[p].l].val &gt; tr[tr[p].r].val) { tr[p].val = tr[tr[p].l].val; tr[p].ans = tr[tr[p].l].ans; } else if (tr[tr[p].l].val &lt; tr[tr[p].r].val) { tr[p].val = tr[tr[p].r].val; tr[p].ans = tr[tr[p].r].ans; } else { tr[p].val = tr[tr[p].l].val; tr[p].ans = tr[tr[p].l].ans + tr[tr[p].r].ans; } }void ins(int &amp;p, int k, int val, int l = 1, int r = n){ if (!p) p = neww(); if (l == r){tr[p].val += val; tr[p].ans = l; return;} int mid = (l + r) &gt;&gt; 1; if (k &lt;= mid) ins(tr[p].l, k, val, l, mid); else ins(tr[p].r, k, val, mid+1, r); pushup(p);}int merge(int x, int y, int l = 1, int r = n){ if (!x || !y) return x + y; if (l == r) {tr[x].val += tr[y].val; tr[x].ans = l;} else { int mid = (l + r) &gt;&gt; 1; tr[x].l = merge(tr[x].l, tr[y].l, l, mid); tr[x].r = merge(tr[x].r, tr[y].r, mid+1, r); pushup(x); } del(y); return x;}int ans[N];void dfs_mg(int cur, int fa){ for (int i = he[cur]; i; i = ne[i]) { int y = ver[i]; if (y == fa) continue; dfs_mg(y, cur); rt[cur] = merge(rt[cur], rt[y]); } ans[cur] = tr[rt[cur]].ans; return;}signed main(){ cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) { scanf(\"%lld\", &amp;su[i]); ins(rt[i], su[i], 1); } for (int i = 1; i &lt; n; i++) { int x, y; scanf(\"%lld%lld\", &amp;x, &amp;y); add(x, y); add(y, x); } dfs_mg(1, 0); for (int i = 1; i &lt;= n; i++) printf(\"%lld \", ans[i]); puts(\"\"); return 0;}","categories":[{"name":"算法竞赛","slug":"算法竞赛","permalink":"http://kalzncc.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"}],"tags":[{"name":"ICPC","slug":"ICPC","permalink":"http://kalzncc.github.io/tags/ICPC/"},{"name":"数据结构","slug":"数据结构","permalink":"http://kalzncc.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"SMO算法流程","slug":"smo","date":"2022-11-19T12:42:37.000Z","updated":"2022-11-22T02:28:47.334Z","comments":true,"path":"2022/11/19/smo/","link":"","permalink":"http://kalzncc.github.io/2022/11/19/smo/","excerpt":"","text":"SMO 算法流程 python代码见github 问题简介 SMO(Sequential Minimal Optimization)用于解决支持向量机中的对偶问题的最优化求解过程，该问题为： 而此问题也满足KKT条件要求 流程 该问题是一种凸二次规划问题，但是如果当作一般情况处理，计算过于繁琐。好在我们可以利用该问题特殊情况，得以特殊处理以简化流程。 SMO算法的核心思想是利用这一条件，进行特殊处理。由于一次性确定所有的最优化取值是十分困难，所谓我们不妨每次只考虑变更两个变量，然后唯一确定剩下的变量为。这里为什么选择两个变量，每次只选择一个不应该更容易吗？这里我们要注意，我们是通过迭代的方式每次选取一组的值进行更改。鉴于条件，我们是无法对单一进行修改的，换句话说，如果我们更改了一个变量，则必须有另一个变量跟随发生改变以满足。 以下，为了表述方便，我们每次选择的变量定为，此时目标函数可以写成： 这里我们把与无关的常数项都简写为，因为这部分在接下来的求导过程中无用。 这里引入我们之前的条件,并设定 带入消去得 其中 我们需要对其最大化，这里进行求导,赋值0求极值 至此，问题似乎得以解决，我们似乎只需要通过该等式解出即可。但是，请再次注意，我们是通过迭代的方式每次选取一组进行优化的。而注意到变量，它的取值为：，其中其他的变量我们无法获悉。我们只知道在之前的迭代中确定的旧值。 所以，这里我们考虑如何调整的数值。即，如何通过旧值推定出新值。我们假定，在之前的迭代中已经确定了一个拟定分隔超平面 这里为上一次迭代中的旧的值。这里我们明确，在此轮迭代中，改变的只有，所以有 所以我们将带入 将其带入得 其中为误差函数 但此时，我们还没有考虑到条件： 由于,故，上式无非就四种情况 其中(2)(3)可以归为一种情况 其中可以归结为。 满足线性规划 在这里插入图片描述 在这种情况下，应满足 。定义 此外，(1)(4)可以归为另一种情况 在这里插入图片描述 在这种情况下，应满足。定义 所以最后更新 至此我们确定了得更新值，然后的值也随之推出。这里我们设 则有 这里我们需要明确一件事情，到目前为止，我们所作的事情就是求这个目标函数得极值，通过分析可以发现是一个二次多项式函数，而二次项的系数为。所以目前来说，上述结论仅在时成立，因为此时是个开口向下的二次函数，存在极值为最小值。这种情况实际上可以应对大部分情况。但是在一部分情况，此时函数极小值在定义域边界出现。当然，在算法的实际实现中，我们可以直接求出定义域的两端值和极值，然后取三者中的最小值即可。 接下来，我们将讨论偏置的值如何求出。根据KKT条件可得，即有 带入误差函数得 其中为旧的偏置值，将该式子代入替换上式的前两项 同理可以得出 而最终的要取两者的中间值，即 最后，我们来讨论，如何进行变量的选取。首先我们应该确定第一个变量，此时，我们变量样本集，选取第一个不满足KKT条件的样本。这里写作KKT条件为： 然后依照规则选取第二个变量，执行优化。当完成后，我们开始遍历非边界样例集（即满足的样例），同样选择第一个不满足KKT条件的变量，然后依照一定规则选择出第二个变量进行优化。完成后，我们再次选择整个样本集进行以上操作。总得来说，我们交替选择整个样本集和非边界样本集进行优化，直至整个样本集全部满足KKT条件。 关于选取第二个变量的规则，我们的原则是让尽可能大的发生变化，由于依赖所以当为正，则要尽量小，否则要尽量大。 有时按照上述的启发式选择第二个变量，不能够使得函数值有足够的下降，这时按下述步骤: &gt; 首先在非边界集上选择能够使函数值足够下降的样本作为第二个变量， 如果非边界集上没有，则在整个样本集上选择第二个变量， 如果整个样本集依然不存在，则重新选择第一个变量。 参考 1.https://blog.csdn.net/luoshixian099/article/details/51227754 2.https://www.cnblogs.com/jerrylead/archive/2011/03/18/1988419.html 3.https://www.jianshu.com/p/0c433f6f4141 4.https://zhuanlan.zhihu.com/p/257866920 5.John Platt.Sequential Minimal Optimization: A Fast Algorithm for Training Support Vector Machines (https://www.microsoft.com/en-us/research/publication/sequential-minimal-optimization-a-fast-algorithm-for-training-support-vector-machines/)","categories":[{"name":"AI","slug":"AI","permalink":"http://kalzncc.github.io/categories/AI/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://kalzncc.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"基于C++的朴素贝叶斯分类器","slug":"simple-bayes","date":"2022-11-19T12:41:26.000Z","updated":"2022-11-22T02:28:50.392Z","comments":true,"path":"2022/11/19/simple-bayes/","link":"","permalink":"http://kalzncc.github.io/2022/11/19/simple-bayes/","excerpt":"","text":"基于C++的朴素贝叶斯分类器 github链接 使用c++编写的朴素贝叶斯分类器，其中似然中的离散分量，以及先验概率使用拉普拉斯平滑，连续分量为正态分布。 警告，此代码仅为初学学习之用，请勿用作任何工程项目！ 一、跑起来 方式一 使用vscode+cmake插件或者Clion打开目录。然后直接编译运行。 方式二 1、确保安装cmake环境，没有请先装cmake。 2、在工程目录下键入： 1234mkdir buildcd buildcmake ..make 3、运行build目录下的程序Bayers_classifier程序 二、用起来 1、建立模型 123456789101112131415161718Simple_Bayes_Classifier::Info info;/** struct Info { int sample_num; // 样例数量 std::vector&lt;int&gt; header; // 样例格式， // 如当前分量为离散值则为样例可能取值的数量， // 如为连续值则填0， // 例如，现有样例格式为这样 : // x0 属于 {\"东\",\"南\",\"西\",\"北\"} // x1 属于 {\"左\",\"右\"} // x2 属于 {x|0&lt;x&lt;100} 为连续值 // 则 header={4, 2, 0} int class_num; // 分类数量 int sample_size; // 样例分量维度大小 } */Simple_Bayes_Classifier model(info); 2、读取文件，训练模型 1model.train(\"data/1.txt\"); // 文件格式为：每行一个样例，每个样例n个分量用空格隔开，最后为该样例所属分类 示例文件格式： 3、开始分类, 构造出一个待分类的样例，然后分类结果赋值到样例的belong_to字段 1234Sample s;s.add_parameter(x); s.add_parameter(y);model.classify(s);std::cout &lt;&lt; s.belong_to &lt;&lt; std::endl; 三、学起来 贝叶斯分类器的基石为Bayes公式： 若现在存在样例的向量为，而其所属分类为的概率为： 其中，我们把称为先验概率（prior），而则为似然（likelihood）而称为证据（evidence）。当分类器工作时，遵循，我们需要比较种分类，选择概率最大的分类。 而 所以我们可以忽略证据，针对每个待分类的样例，对每种分类计算先验概率和似然即可。 先验概率一般直接进行数量统计，即: 其中为训练集中。所属类别的样例集，而为全体训练集。 而计算较为困难的是似然，在朴素贝叶斯中，我们认为向量的所有分量的取值是独立的,此时有: 此时即可进行运算，这里如果为离散值，则可以直接进行统计： 其中是训练集中满足：所属类别为且分量为的集合。 而如果为连续值，则这里可以将其看成正态分布: 其中分别为所属类别为的训练集的分量的方差和均值。 至此我们解决了朴素贝叶斯分类器。 在有些时候，向量的分量不是独立的，一种常见的情况是所有分量满足多维正态分布。为了清晰设置 其中 这里我们将结果取对数 此时有决策函数： 为决策界，当归为类，否则归为。至此，我们讨论了贝叶斯分类器中，样例各分量满足多维正态分布的情况。","categories":[{"name":"AI","slug":"AI","permalink":"http://kalzncc.github.io/categories/AI/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://kalzncc.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"使用C++实现的简单ANN（人工神经网络）","slug":"ml-ann","date":"2022-11-19T12:01:22.000Z","updated":"2022-11-22T02:28:40.209Z","comments":true,"path":"2022/11/19/ml-ann/","link":"","permalink":"http://kalzncc.github.io/2022/11/19/ml-ann/","excerpt":"","text":"使用C++实现的简单ANN（人工神经网络） github地址 使用C++实现的最简单的人工神经网络，包含梯度下降的反向传播算法（BP）。内有部分注释，适合初学学习。至于为什么不用python？还是觉得从最底层（矩阵运算）写比较能加深印象和对算法的理解。（绝对不是因为我不会写python） 警告，此代码仅为初学学习之用，请勿用作任何工程项目！ 一、跑起来 方式一 使用vscode+cmake插件或者Clion打开目录。然后直接编译运行。 方式二 1、确保安装cmake环境，没有请先装cmake。 2、在工程目录下键入： 1234mkdir buildcd buildcmake ..make 3、运行build目录下的ANN程序 然后在data目录下生成文件output.csv,这是一个回归函数的拟合。 拟合情况如下： 二、用起来 1、使用十分简便，首先新建ANN模型，设置误差函数cost及其对于输出层每一项的偏导，这里使用默认的平方差函数 123ANNModel model;model.cost = Sqrt_Cost_Func::sqrt_cost;model.d_cost = Sqrt_Cost_Func::d_sqrt_cost; 1、设置学习率（一般0.0001~0.1） 1model.learning_rate = 0.01; 2、开始添加层级，从输入层开始，直到输出层，这里请保证输入层的神经元个数与输入向量的维度相同。并设置这些层级的激活函数和其导数。 123456789101112131415161718// 输入层 1个神经元ANNLayer layer0(1);layer0.activition = Linear_Func::linear; // 设置本层激活函数为线性函数f(x)=x // 根据ANN结构，输入层的激活函数应设置为线性layer0.d_activition = Linear_Func::linear;// 设置本层激活函数的导数model.add_layer(layer0);// 隐藏层 20个神经元ANNLayer layer1(20);layer1.activition = Signmod_Func::signmod; // 设置本层激活函数为sigmodlayer1.d_activition = Signmod_Func::d_signmod;model.add_layer(layer1);// 输出层1个神经院ANNLayer layer2(1);layer2.activition = Linear_Func::linear;layer2.d_activition = Linear_Func::d_linear;model.add_layer(layer2); 3、编译模型 1Compiled_ANNModel compiled_model = model.compile(); 4、训练模型，查看输出 12Vector data, expectation;Vector output = compiled_model.feed(data, expectation); 5、只输出，不训练 1Vector output = compiled_model.get_output(data); 三、学起来 这里给出最终公式，公式的推导请见其他教程、参考书。 1、获得神经元的激活值，这里使用表示第层的第个神经元的激活值大小 其中 其中为第层的激活函数，为从层第个神经元链接到第层第个神经元的边权（注意下标的顺序！），另外是第层第个神经元的偏置阈值。为第层的神经元个数。 2、反向传播公式（以平方差误差函数为例） 其中 最终有 最后对、进行更新如下 其中，为第层激活函数的导数。为误差函数，为预期输出向量的分量。为学习率。 具体实现的解释请，见代码注释。","categories":[{"name":"AI","slug":"AI","permalink":"http://kalzncc.github.io/categories/AI/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://kalzncc.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]},{"title":"关于我","slug":"about-me","date":"2022-11-19T11:30:11.000Z","updated":"2022-11-21T08:23:06.243Z","comments":true,"path":"2022/11/19/about-me/","link":"","permalink":"http://kalzncc.github.io/2022/11/19/about-me/","excerpt":"","text":"这里是Kalzn，打过ICPC但没拿过金，打过CCPC但也没拿过金，打过蓝桥但没拿过第一，上过大学但是双非，在中科院读研但不是计算(自动化、软件)所。 写博客主要是给自己看，顺带给阁下带来点帮助。 有关ICPC的东西应该不会更了(找工作的时候可能会再更？)，读研之后就不怎么接触了，目前主要更机器学习、项目代码。","categories":[],"tags":[{"name":"置顶","slug":"置顶","permalink":"http://kalzncc.github.io/tags/%E7%BD%AE%E9%A1%B6/"}]},{"title":"博客迁移说明，我是Kalzn","slug":"hello-world","date":"2022-11-19T09:52:43.465Z","updated":"2022-11-19T12:14:27.708Z","comments":true,"path":"2022/11/19/hello-world/","link":"","permalink":"http://kalzncc.github.io/2022/11/19/hello-world/","excerpt":"","text":"我懒，所以一直不想迁移博客，所以对CSDN广告的容忍还是很高的。 但是由于最近CSDN的广告真的是让我忍无可忍（开屏一个网页的超大广告是搞什么？）所以还是花点时间迁过来吧。之后CSDN还会更新，但是说不定那天就完全转移过来了捏。之前的博客我会慢慢搬（github找了一圈，也没找见有博客搬迁的脚本，有无大佬搞一搞。） CSDN链接","categories":[],"tags":[]}],"categories":[{"name":"博客改造","slug":"博客改造","permalink":"http://kalzncc.github.io/categories/%E5%8D%9A%E5%AE%A2%E6%94%B9%E9%80%A0/"},{"name":"算法竞赛","slug":"算法竞赛","permalink":"http://kalzncc.github.io/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"AI","slug":"AI","permalink":"http://kalzncc.github.io/categories/AI/"}],"tags":[{"name":"置顶","slug":"置顶","permalink":"http://kalzncc.github.io/tags/%E7%BD%AE%E9%A1%B6/"},{"name":"博客","slug":"博客","permalink":"http://kalzncc.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"蓝桥","slug":"蓝桥","permalink":"http://kalzncc.github.io/tags/%E8%93%9D%E6%A1%A5/"},{"name":"ICPC","slug":"ICPC","permalink":"http://kalzncc.github.io/tags/ICPC/"},{"name":"数据结构","slug":"数据结构","permalink":"http://kalzncc.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"机器学习","slug":"机器学习","permalink":"http://kalzncc.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}]}